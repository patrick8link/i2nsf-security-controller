<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;32.&nbsp;Advanced Topics</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="ConfD User Guide"><link rel="up" href="index.html" title="ConfD User Guide"><link rel="prev" href="ch31.html" title="Chapter&nbsp;31.&nbsp;Progress Trace"><link rel="next" href="rn01.html" title="ConfD man-pages, Volume 1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;32.&nbsp;Advanced Topics</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch31.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="rn01.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="ug.advanced"></a>Chapter&nbsp;32.&nbsp;Advanced Topics</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="ch32.html#d5e15263">32.1. Locks</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.target">32.2. Installing ConfD on a target system</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.config_confd">32.3. Configuring ConfD</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.starting_confd">32.4. Starting ConfD</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.confd_ipc">32.5. ConfD IPC</a></span></dt><dt><span class="sect1"><a href="ch32.html#d5e15894">32.6. Restart strategies</a></span></dt><dt><span class="sect1"><a href="ch32.html#d5e15906">32.7. Running ConfD as a non privileged user</a></span></dt><dt><span class="sect1"><a href="ch32.html#d5e15927">32.8. Storing encrypted values in ConfD</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.disaster">32.9. Disaster management</a></span></dt><dt><span class="sect1"><a href="ch32.html#d5e16129">32.10. Troubleshooting</a></span></dt><dt><span class="sect1"><a href="ch32.html#d5e16294">32.11. Tuning the size of confd_hkeypath_t</a></span></dt><dt><span class="sect1"><a href="ch32.html#d5e16347">32.12. Configuring NETCONF receive buffer size</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.custom.msgs">32.13. Error Message Customization</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.different_openssl">32.14. Using a different version of OpenSSL and optionally
    activating FIPS</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.shared_memory_schema">32.15. Using shared memory for schema information</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.internal_econfd">32.16. Running application code inside ConfD</a></span></dt><dt><span class="sect1"><a href="ch32.html#ug.advanced.external_logging">32.17. External Logging</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e15263"></a>32.1.&nbsp;Locks</h2></div></div></div><p>This section will explain the different locks that exist in
      ConfD and how they interact. It is important to understand the
      architecture of ConfD with its management backplane, and the
      transaction state machine as described in
      <a class="xref" href="ch10.html#ug.ext_data.user_sessions" title="10.5.&nbsp;User sessions and ConfD Transactions">Section&nbsp;10.5, &#8220;User sessions and ConfD Transactions&#8221;</a>
      to be able to understand how the different locks fit
      into the picture.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e15267"></a>32.1.1.&nbsp;Global locks</h3></div></div></div><p>The ConfD management backplane keeps a lock for each
      datastore: running, startup and candidate. These locks are
      usually referred to as the global locks and they provide a
      mechanism to grant exclusive access to the datastore the lock
      guards.</p><p>The global locks are the only locks that can explicitly be
      taken through a northbound agent, for example by the NETCONF
      <code class="code">&lt;lock&gt;</code> operation, or by calling
      <code class="code">maapi_lock()</code>.</p><p>A global lock can be taken for the whole datastore, or it can
      be a partial lock (for a subset of the datamodel). Partial locks
      are exposed through NETCONF and MAAPI.</p><p>An agent can request a global lock to ensure that it has
      exclusive write-access to a datastore. When a global lock is
      held by an agent it is not possible for anyone else to write to
      the datastore the lock guards - this is enforced by the
      transaction engine. A global lock on a datastore is granted to
      an agent if there are no other holders of it (including partial
      locks), and if all dataproviders approve the lock request. Each
      dataprovider (CDB and/or external dataproviders) will have its
      <code class="code">lock()</code> callback invoked to get a chance to refuse or
      accept the lock. The output of <span class="command"><strong>confd --status</strong></span> includes
      locking status. For each user session locks (if any) per
      datastore is listed.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e15277"></a>32.1.2.&nbsp;Transaction locks</h3></div></div></div><p>A northbound agent starts a user session towards ConfD's
      management backplane. Each user session can then start multiple
      transactions. A transaction is either read/write or read-only
      and is always started against a specific datastore.</p><p>The transaction engine has its internal locks, one for every
      datastore. These transaction locks exists to serialize
      configuration updates towards the datastore and are separate
      from the global locks.</p><p>As a northbound agent wants to update a datastore with a new
      configuration it will implicitly grab and release the
      transactional lock corresponding to the datastore it is trying
      to modify. The transaction engine takes care of managing the
      locks, as it moves through the transaction state machine and
      there is no API that exposes the transactional locks to the
      northbound agents.</p><p>When the transaction engine wants to take a lock for a
      transaction (for example when entering the validate state) it
      first checks that no other transaction has the lock. Then it
      checks that no user session has a global lock on that
      datastore. Finally each dataprovider is invoked by its
      <code class="code">trans_lock()</code> callback.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e15284"></a>32.1.3.&nbsp;Northbound agents and global locks</h3></div></div></div><p>In contrast to the implicit transactional locks, some
      northbound agents expose explicit access to the global
      locks. This is done a bit differently by each agent.</p><p>The management API exposes the global locks by providing
      <code class="code">maapi_lock()</code> and <code class="code">maapi_unlock()</code>
      functions (and the corresponding <code class="code">maapi_lock_partial()</code>
      <code class="code">maapi_unlock_partial()</code> for partial locking). Once a user
      session is established (or attached to) these functions can be
      called.</p><p>In the CLI the global locks are taken when entering different
      configure modes as follows:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
            <span class="command"><strong>configure exclusive</strong></span>
          </span></dt><dd><p>When the candidate datastore is enabled both the
        running and candidate global locks will be taken.</p></dd><dt><span class="term"><span class="command"><strong>configure exclusive</strong></span></span></dt><dd><p>When the candidate datastore is disabled and the
          startup datastore is enabled both running (if enabled) and
        startup global locks are taken.</p></dd><dt><span class="term"><span class="command"><strong>configure private | shared</strong></span></span></dt><dd><p>Does not grab any locks</p></dd></dl></div><p>The global locks are then kept by the CLI until either the
      configure mode is exited, or in the case of
      <span class="command"><strong>commit confirmed &lt;timeout&gt;</strong></span> the lock is
      released when it returns.</p><p>The Web UI behaves in the same way as the CLI (it presents
      three edit tabs called "Edit private", "Edit exclusive", and
      "Edit shared" which corresponds to the CLI modes described
      above).</p><p>The NETCONF agent translates the <code class="code">&lt;lock&gt;</code>
      operation into
      a request for the global lock for the requested
      datastore. Partial locks are also exposed through the
      partial-lock rpc.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e15314"></a>32.1.4.&nbsp;External data providers</h3></div></div></div><p>Implementing the <code class="code">lock()</code> and <code class="code">unlock()</code> callbacks
      is not required of an external dataprovider. ConfD will never
      try to initiate the <code class="code">trans_lock()</code> state transition (see
      the transaction state diagram in
      <a class="xref" href="ch10.html#ug.ext_data.user_sessions" title="10.5.&nbsp;User sessions and ConfD Transactions">Section&nbsp;10.5, &#8220;User sessions and ConfD Transactions&#8221;</a>)
      towards a data provider while a global lock is taken - so the
      reason for a dataprovider to implement the locking callbacks is
      if someone else can write (or lock for example to take a backup)
      to the data providers database.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e15321"></a>32.1.5.&nbsp;CDB</h3></div></div></div><p>CDB ignores the <code class="code">lock()</code> and <code class="code">unlock()</code> callbacks
      (since the data-provider interface is the only write interface
      towards it).</p><p>CDB has its own internal locks on the database. The running
      and startup datastore each has a single write and multiple read
      locks. It is not possible to grab the write-lock on a datastore
      while there are active read-locks on it. The locks in CDB exists
      to make sure that a reader always gets a consistent view of the
      data (in particular it becomes very confusing if another user is
      able to delete configuration nodes in between calls to get_next() on
      YANG list entries).</p><p>During a transaction <code class="code">trans_lock()</code> takes a CDB
      read-lock towards the transactions datastore and write_start()
      tries to release the read-lock and grab the write-lock
      instead.</p><p>A CDB external client (usually referred to as an MO, managed
      object) implicitly takes a CDB read-lock between
      <code class="code">cdb_start_session()</code> and <code class="code">cdb_end_session()</code> on the
      specified datastore (running or startup). This means that while
      an MO is reading, a transaction can not pass through
      <code class="code">write_start()</code> (and conversely a CDB reader can not start
      while a transaction is in between <code class="code">write_start()</code> and
      <code class="code">commit()</code> or <code class="code">abort()</code>).</p><p>The Operational store in CDB does not have any locks. ConfD's
      transaction engine can only read from it, and the MO writes are
      atomic per write operation.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e15337"></a>32.1.6.&nbsp;Lock impact on user sessions</h3></div></div></div><p>
        When a session tries to modify a data store that is locked in
        some way, it will fail.  For example, the CLI might print:
      </p><div class="informalexample"><pre class="screen">
admin@host% commit
Aborted: the configuration database is locked
[error][2009-06-11 16:27:21]
        </pre></div><p>
        Since some of the locks are short lived (such as a CDB read
        lock), ConfD can be configured to retry the failing operation
        for a short period of time.  If the data store still is locked
        after this time, the operation fails.
      </p><p>
        To configure this, set
        <code class="sgmltag-element">/confdConfig/commitRetryTimeout</code> in
        <code class="filename">confd.conf</code>.
      </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.target"></a>32.2.&nbsp;Installing ConfD on a target system</h2></div></div></div><p>
        The ConfD installation package contains both binaries for the
        target system and a development environment including
        documentation. Many of these files are not needed on a target,
        and can be excluded. Additional files can be removed depending
        on the feature configuration on the target.
      </p><p>
        In the following description, <code class="filename">$CONFD_DIR</code>
        refers to the directory where ConfD has been installed.
      </p><p>
        A minimal example set of files on a target system can be:
      </p><div class="informalexample"><pre class="screen">$CONFD_DIR/bin/confd
$CONFD_DIR/etc/confd/*fxs
$CONFD_DIR/lib/confd/bin/*
$CONFD_DIR/lib/confd/erts/*
$CONFD_DIR/lib/confd/lib/core/*
$CONFD_DIR/lib/confd/lib/netconf/*</pre></div><p>
        This target system has only NETCONF as northbound agent and no
        examples, no source code and no development tools.
      </p><p>
        <code class="filename">$CONFD_DIR/etc/confd/</code> contains
        configuration files and does not need to be located under
        <code class="filename">$CONFD_DIR</code>.
      </p><p>
        Files associated with certain features can be removed if the
        system is set up not to use them:
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Optional utilities</span></dt><dd><div class="informalexample"><pre class="screen">$CONFD_DIR/bin/confd_cmd
$CONFD_DIR/bin/confd_load
$CONFD_DIR/bin/maapi
$CONFD_DIR/bin/netconf-console
$CONFD_DIR/bin/netconf-console-tcp</pre></div></dd><dt><span class="term">The CLI agent</span></dt><dd><div class="informalexample"><pre class="screen">$CONFD_DIR/bin/confd_cli
$CONFD_DIR/etc/confd/confd.ccl
$CONFD_DIR/lib/confd/lib/cli*</pre></div></dd><dt><span class="term">The NETCONF server</span></dt><dd><div class="informalexample"><pre class="screen">$CONFD_DIR/lib/confd/lib/netconf*
$CONFD_DIR/etc/confd/ietf-netconf-* (except ietf-netconf-acm.fxs)
$CONFD_DIR/etc/confd/tailf-netconf-*
        </pre></div></dd><dt><span class="term">Optional NETCONF modules</span></dt><dd><div class="informalexample"><pre class="screen">Tail-f specific NETCONF modules can be removed:
$CONFD_DIR/etc/confd/tailf-netconf-*</pre></div></dd><dt><span class="term">The Web UI and REST server</span></dt><dd><div class="informalexample"><pre class="screen">$CONFD_DIR/lib/confd/lib/webui*
$CONFD_DIR/etc/confd/ietf-restconf-monitoring.fxs
$CONFD_DIR/etc/confd/tailf-webui.fxs</pre></div></dd><dt><span class="term">The Web UI frontend</span></dt><dd><div class="informalexample"><pre class="screen">$CONFD_DIR/var/confd/webui*
$CONFD_DIR/etc/confd/tailf-webui.fxs</pre></div></dd><dt><span class="term">The SNMP agent and gateway</span></dt><dd><div class="informalexample"><pre class="screen">$CONFD_DIR/bin/smidump
$CONFD_DIR/lib/confd/lib/snmp*</pre></div><p>
            <span class="command"><strong>smidump</strong></span> is only used for producing YANG
            files - it is not used by ConfD itself, and therefore not
            likely to be needed on the target.
          </p></dd><dt><span class="term">The integrated SSH server</span></dt><dd><p>
            The integrated SSH server is not needed if OpenSSH is used
            to terminate SSH for NETCONF and the CLI:
          </p><div class="informalexample"><pre class="screen">$CONFD_DIR/lib/confd/lib/core/ssh*</pre></div></dd><dt><span class="term">The confdc compiler</span></dt><dd><p>
            The compiler can be removed unless we plan to to
            compile YANG files on the host.
          </p><div class="informalexample"><pre class="screen">$CONFD_DIR/bin/confdc
$CONFD_DIR/bin/cs2yang
$CONFD_DIR/bin/pyang
$CONFD_DIR/bin/yanger
$CONFD_DIR/lib/confd/lib/confdc*
$CONFD_DIR/lib/cs2yang*
$CONFD_DIR/lib/pyang*</pre></div></dd><dt><span class="term">The AAA bridge</span></dt><dd><p>
            See documentation on AAA - basically this is a
            pre-compiled example program which probably won't be used
            on target:
          </p><div class="informalexample"><pre class="screen">$CONFD_DIR/lib/confd/lib/core/capi/priv/confd_aaa_bridge</pre></div></dd><dt><span class="term">Static libraries</span></dt><dd><p>
            These static libraries makes no sense on target:
          </p><div class="informalexample"><pre class="screen">$CONFD_DIR/lib/libconfd.a</pre></div></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.config_confd"></a>32.3.&nbsp;Configuring ConfD</h2></div></div></div><p>
        When ConfD is started, it reads its configuration file and
        starts all subsystems configured to start (such as NETCONF,
        CLI etc.). If a configuration parameter is changed, ConfD can be
        reloaded by issuing:
      </p><div class="informalexample"><pre class="screen">$ confd --reload</pre></div><p>
        This command also tells ConfD to close and reopen all log
        files, which makes it suitable to use from a system like
        <span class="command"><strong>logrotate</strong></span>.
      </p><p>
        There is also another way, whereby the ConfD configuration
        parameters that can be changed in runtime are loaded from an
        external namespace. Thus allowing the user to store ConfD's
        configuration in ConfD (specifically in CDB) itself. This will
        be described further down.
      </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e15429"></a>32.3.1.&nbsp;Using the configuration file</h3></div></div></div><p>
        On a typical system, the configuration data resides in ConfD's
        database CDB. Some of the parameters in the configuration are
        intended for the target OS environment, such as the IP address
        of the management interface. The OS reads this information
        from its own configuration files, such as
        <code class="filename">/etc/conf.d/net</code>. This means that the application
        typically reads this data from CDB, and generates
        configuration files needed by the system before starting
        them. If a manager changes one of these parameters, the
        application subscribes to changes in CDB, regenerates the
        files, and restarts the system daemons. This mechanism can
        also be used for the configuration of ConfD itself. The
        application must subscribe to changes to any parameter
        affecting ConfD (such as management IP address), update the
        ConfD configuration file <code class="filename">confd.conf</code>, and then
        instruct ConfD to reload it.
      </p><p>
        ConfD comes bundled with a small example tool which can be
        used to patch <code class="filename">confd.conf</code> files:
        <code class="filename">$CONFD_DIR/src/confd/tools/xmlset.c</code>. This tool
        uses the light-weight Expat XML Parser
        (http://expat.sourceforge.net/).
      </p><p>
        This example changes <code class="filename">confd.conf</code> to disable the Web UI:
      </p><div class="informalexample"><pre class="screen">$ xmlset C false confdConfig webui enabled &lt; confd.conf</pre></div><p>
        This example changes <code class="filename">confd.conf</code> to removes the
        encryptedStrings container:
      </p><div class="informalexample"><pre class="screen">$ xmlset R confdConfig encryptedStrings &lt; confd.conf</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ug.advanced.config_confd_dyn"></a>32.3.2.&nbsp;Storing ConfD configuration parameters in CDB</h3></div></div></div><p>
            In the ConfD distribution in the
            <code class="filename">$CONFD_DIR/src/confd/dyncfg</code> directory the
            <code class="filename">confd_dyncfg.yang</code> YANG module is included.
            The module defines the
            namespace <span class="emphasis"><em>http://tail-f.com/ns/confd_dyncfg/1.0</em></span>
            which contains all the ConfD configuration parameters that
            can be modified in runtime. I.e. it is a subset of the
            namespace that defines the ConfD configuration file
            (<code class="filename">confd.conf</code>).
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            The <code class="filename">confd_dyncfg.yang</code> file in this directory
            is implemented by ConfD and should therefore not be modified.
            If modified, ConfD may behave unpredictably.
          </p></div><p>
            To enable the feature of storing ConfD's configuration in
            CDB the
            setting <code class="sgmltag-element">/confdConfig/runtimeReconfiguration</code> has
            to be set to <span class="emphasis"><em>namespace</em></span> in the configuration
            file. This instructs ConfD to read all its "static"
            configuration from the configuration file, and then load
            the rest of the configuration from the confd_dyncfg
            namespace (which must be served by CDB). A requirement is
            that the confd_dyncfg.fxs is in
            ConfD's <span class="emphasis"><em>loadPath</em></span>. It is also advisable to have a
            suitable <code class="filename">_init.xml</code> file in ConfD's CDB directory.
          </p><p>
            The best way to understand how to use this feature is the
            example <code class="filename">confdconf/dyncfg</code> in the bundled example
            collection.
          </p><p>
            In most cases the interesting use of this feature is to be
            able to expose a particular aspect of ConfD's
            configuration to the end-user and hide the rest. This can
            be achieved by combining the use of the
            <span class="command"><strong>--export none</strong></span> flag when compiling the
            <code class="filename">confd_dyncfg.yang</code>
            module with the use of the link feature (exactly how
            they work are explained in
            <a class="xref" href="ch13.html#ug.transformations.hidden_data" title="13.7.&nbsp;Hidden Data">Section&nbsp;13.7, &#8220;Hidden Data&#8221;</a>).
            The
            <code class="filename">snmpa/6-dyncfg</code> example in the
            example collection shows how to expose a small subset of
            the SNMP agent configuration (as well as some minor
            aspects of the CLI parameters) in a private namespace.
          </p><p>
            For example, if we want to be able to expose the
            ConfD's built-in SNMP agents listen port as an end-user
            configurable as the leaf <code class="sgmltag-element">/sys/snmp-port</code>, we
            could write a YANG model like this:
          </p><div class="informalexample"><pre class="programlisting">container sys {
          leaf snmp-port {
            type inet:port-number;
            tailf:link "/dyncfg:confdConfig/dyncfg:snmpAgent/dyncfg:port";
          }
        }
      }</pre></div><p>
            When a transaction containing changes to <code class="sgmltag-element">/confdConfig</code>
            is committed ConfD will pick up the changes made and act
            accordingly. Thus there is no longer a need for
            <span class="command"><strong>confd --reload</strong></span> except for closing/re-opening
            of log-files
            (as described above) or to update the fxs files for
            sub-agents.
          </p><p>
            When <code class="sgmltag-element">/confdConfig/runtimeReconfiguration</code> is set
            to <span class="emphasis"><em>namespace</em></span>, any settings in
            <code class="filename">confd.conf</code> for the parameters that
            exist in the <code class="sgmltag-element">confd_dyncfg</code> namespace are ignored,
            with one exception: the configuration under
            <code class="sgmltag-element">/confdConfig/logs</code>. This configuration is needed
            before CDB has started, and ConfD will therefore initially
            use the settings from <code class="filename">confd.conf</code>, with
            the CDB settings taking precedence once CDB has started
            (i.e. when the transition to phase1 is completed).
          </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.starting_confd"></a>32.4.&nbsp;Starting ConfD</h2></div></div></div><p>
        By default, ConfD starts in the background without an
        associated terminal.  If it is started as
        <span class="command"><strong>confd --foreground</strong></span>, it starts in the
        foreground attached to the
        current terminal.  This feature can be used to start ConfD
        from a process manager. In order to properly stop ConfD in the
        foreground case, close ConfD's standard input, or use
        <span class="command"><strong>confd --stop</strong></span> as usual.  When ConfD is started in the
        foreground, the commands <span class="command"><strong>confd --wait-phase0</strong></span> and
        <span class="command"><strong>confd --wait-started</strong></span> can be used to synchronize the
        startup sequence.  See below for more details.
      </p><p>
        If startup or candidate with confirming-commit is used, the
        system might need to use a configuration which is different
        from the previous running when it reboots. An example of this
        is if startup is used, and a manager writes a configuration
        into running which renders the device unstable, and it is
        rebooted. It might be that the management IP address used by
        the OS is not the one that should be used (if it was changed
        before reboot). We'd like to be able to change this address in the
        OS configuration files before bringing up the interface. But
        we don't know the address until ConfD has been started, and
        ConfD itself needs to listen to this address. To solve this
        dilemma, ConfD's startup sequence can be split into several
        phases. The first phase brings up the ConfD daemon, but no
        subsystems that listen to the management IP address (such as
        NETCONF and CLI). This phase must be started after the
        loopback interface has been brought up, since the loopback
        interface is used to communicate between the application and
        ConfD.
      </p><p>
        It is also necessary to use the start phases when CDB is used
        and semantic validation via external callbacks has been
        implemented. CDB will validate the new configuration when ConfD
        is started without an existing database, as well as when a
        schema upgrade has caused configuration changes. This validation
        is done on the transition to phase1, which means that
        validation callbacks must be registered before this.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        If an application has both validation
        callbacks and other callbacks (e.g. data provider), and uses the
        same daemon structure and control socket through all the phases,
        it must register all the callbacks in phase0. This is because
        the <code class="code">confd_register_done()</code>
        function (see <a class="xref" href="rn02re10.html" title="confd_lib_dp"><span class="refentrytitle">confd_lib_dp</span>(3)</a>)
        must be called after all registrations are done, and no callbacks
        will be invoked before this function has been called. The tables
        below reflect this requirement, but it is also possible to
        register all callbacks in phase0, which may simplify the startup
        sequence (however CDB subscribers can not be added until phase1).
        </p></div><p>
        The sequence to start up the system should be like this:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>bring up the loopback interface</p></li><li class="listitem"><p><span class="command"><strong>confd --start-phase0</strong></span></p></li><li class="listitem"><p>start applications that implement validation callbacks</p></li><li class="listitem"><p><span class="command"><strong>confd --start-phase1</strong></span></p></li><li class="listitem"><p>start remaining applications, read from CDB</p></li><li class="listitem"><p>potentially update <code class="filename">confd.conf</code> and do <span class="command"><strong>confd --reload</strong></span></p></li><li class="listitem"><p>bring up the management interface</p></li><li class="listitem"><p><span class="command"><strong>confd --start-phase2</strong></span></p></li></ol></div><p>
      </p><p>
        Note that if ConfD is started without any parameters, it
        will bring up the entire system at once.
      </p><p>
        This table summarizes the different start-phases and
        what they do.
      </p><div class="table"><a name="d5e15519"></a><p class="title"><b>Table&nbsp;32.1.&nbsp;ConfD Start Phases</b></p><div class="table-contents"><table><thead><tr>
            <td>Command line</td>
            <td>When command returns ConfD has</td>
            <td>After which <span class="emphasis"><em>application</em></span> can/should</td>
          </tr></thead><tbody><tr>
            <td><code class="code">confd --start-phase0</code></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If upgrading or initializing CDB, created an
                initial transaction.</p></li></ul></div>
            </td>
            <td></td>
          </tr><tr>
            <td></td>
            <td></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If upgrading or initializing, the application
                can modify the initial transaction</p></li><li class="listitem"><p>Register validation callbacks</p></li><li class="listitem"><p>Possibly register external data-providers,
                transformations, etc (see Note above)</p></li><li class="listitem"><p>Setup notification sockets</p></li><li class="listitem"><p>Connect to HA</p></li></ul></div>
            </td>
          </tr><tr>
            <td><code class="code">confd --start-phase1</code></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If upgrading or initializing CDB, committed initial
                transaction</p></li></ul></div>
            </td>
            <td></td>
          </tr><tr>
            <td></td>
            <td></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Make HA state transitions</p></li><li class="listitem"><p>Register remaining external data-providers,
                transformation callbacks, etc (see Note above)</p></li><li class="listitem"><p>Add CDB subscribers</p></li></ul></div>
            </td>
          </tr><tr>
            <td><code class="code">confd --start-phase2</code></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Bound and started listening to NETCONF, CLI, Web UI,
                  and SNMP addresses / ports</p></li><li class="listitem"><p>Allowed initiation of MAAPI user sessions</p></li></ul></div>
            </td>
            <td></td>
          </tr></tbody></table></div></div><br class="table-break"><p>
        This table summarizes the different start-phases when ConfD is
        started in the foreground.
      </p><div class="table"><a name="d5e15581"></a><p class="title"><b>Table&nbsp;32.2.&nbsp;ConfD Start Phases, running in foreground</b></p><div class="table-contents"><table><thead><tr>
            <td>Command line</td>
            <td>When command returns ConfD has</td>
            <td>After which <span class="emphasis"><em>application</em></span> can/should</td>
          </tr></thead><tbody><tr>
            <td><code class="code">confd --foreground --start-phase0</code></td>
            <td>
              This command never returns.
            </td>
            <td></td>
          </tr><tr>
            <td><code class="code">confd --wait-phase0</code></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If upgrading or initializing CDB, created an
                initial transaction.</p></li></ul></div>
            </td>
            <td></td>
          </tr><tr>
            <td></td>
            <td></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If upgrading or initializing, the application
                can modify the initial transaction</p></li><li class="listitem"><p>Register validation callbacks</p></li><li class="listitem"><p>Possibly register external data-providers,
                transformations, etc (see Note above)</p></li><li class="listitem"><p>Setup notification sockets</p></li></ul></div>
            </td>
          </tr><tr>
            <td><code class="code">confd --start-phase1</code></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If upgrading or initializing CDB, committed initial
                transaction</p></li></ul></div>
            </td>
            <td></td>
          </tr><tr>
            <td></td>
            <td></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Connect to HA</p></li><li class="listitem"><p>Register remaining external data-providers,
                transformation callbacks, etc (see Note above)</p></li><li class="listitem"><p>Add CDB subscribers</p></li></ul></div>
            </td>
          </tr><tr>
            <td><code class="code">confd --start-phase2</code></td>
            <td>
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Bound and started listening to NETCONF, CLI, Web UI,
                  and SNMP addresses / ports</p></li><li class="listitem"><p>Allowed initiation of MAAPI user sessions</p></li></ul></div>
            </td>
            <td></td>
          </tr></tbody></table></div></div><br class="table-break"></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.confd_ipc"></a>32.5.&nbsp;ConfD IPC</h2></div></div></div><p>
      Client libraries connect to ConfD using TCP. We tell ConfD
      which address to use for these connections through the
      <code class="sgmltag-element">/confdConfig/confdIpcAddress/ip</code> (default value
      127.0.0.1) and <code class="sgmltag-element">/confdConfig/confdIpcAddress/port</code>
      (default value 4565) elements in <code class="filename">confd.conf</code>.
      On Linux it is possible also to specify network namespace and VRF
      that ConfD will use for IPC through the
      <code class="sgmltag-element">/confdConfig/confdIpcAddress/netns</code>
      <code class="sgmltag-element">/confdConfig/confdIpcAddress/vrf</code>
      parameter. Default values for these parameters are empty.
      If specified, network namespace should be a full
      path to the namespace on the filesystem (e.g. /var/run/netns/ipcns).
      If specified, the VRF should be a name of the interface (e.g. vrf0), also
      the IP address belonging to that interface should be specified instead of the
      default IP address in <code class="sgmltag-element">/confdConfig/confdIpcAddress/ip</code>.
      It is possible to change all these values, but it requires a number of
      steps to also configure the networking and the
      clients. Also there are security implications, see section
      <a class="xref" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Security issues">Chapter&nbsp;4, <i>Security issues</i></a>.
    </p><p>
      Some clients read the environment
      variables <code class="code">CONFD_IPC_ADDR</code> and <code class="code">CONFD_IPC_PORT</code> to
      determine if something other than the default is to be used,
      others might need to be recompiled. No client gets network namespace or VRF
      from environment variables or command line parameters. It is up to the invoking
      process to setup the runtime environment so that correct network namespace and
      VRF are used (e.g. by use of <span class="emphasis"><em>ip(8)</em></span> command). Below is a list of
      clients which communicate with ConfD, and what needs to be
      done when <code class="code">confdIpcAddress</code> is changed.
    </p><div class="informaltable"><table><thead><tr><td>Client</td><td>Changes required</td></tr></thead><tbody><tr><td>Remote commands via the <span class="emphasis"><em>confd</em></span> command</td>
        <td>
          Remote commands, such as <span class="command"><strong>confd --reload</strong></span>,
          check the environment
          variables <span class="command"><strong>CONFD_IPC_ADDR</strong></span>
          and <span class="command"><strong>CONFD_IPC_PORT</strong></span>.
        </td>
        </tr><tr><td>CDB and MAAPI clients</td>
        <td>
          The address supplied to <code class="code">cdb_connect()</code> and
          <code class="code">maapi_connect()</code> must be changed.
          If network namespace used by ConfD differs from the default, then
          the proper namespace should be set before communication socket is open.
        </td>
        </tr><tr><td>Data provider API clients</td>
        <td>
          The address supplied to <code class="code">confd_connect()</code>
          must be changed.
        </td>
        </tr><tr><td>confd_cli</td>
        <td>
          <p>
            The Command Line Interface (CLI) client,
            <span class="command"><strong>confd_cli</strong></span>, checks the environment
            variables <code class="code">CONFD_IPC_ADDR</code>
            and <code class="code">CONFD_IPC_PORT</code>. Alternatively the port
            can be provided on the command line (using
            the <span class="command"><strong>-P</strong></span> option).
          </p>
          <p>
            <span class="emphasis"><em>NOTE:</em></span> <span class="command"><strong>confd_cli</strong></span> is provided as source, in
            <span class="emphasis"><em>$CONFD_DIR/src/confd/cli</em></span>, so it is also
            possible to re-compile it using the new address as
            default.
          </p>
        </td>
        </tr><tr><td>Notification API clients</td>
        <td>
          The new address must be supplied to
          <code class="code">confd_notifications_connect()</code>
        </td>
        </tr></tbody></table></div><p>
          Each of parameters in <code class="filename">confd.conf</code> - <code class="sgmltag-element">/confdConfig/confdIpcAddress/port</code>,
          <code class="sgmltag-element">/confdConfig/confdIpcAddress/netns</code>,
          <code class="sgmltag-element">/confdConfig/confdIpcAddress/vrf</code> - can be used as a
          differentiator to run more than one instance of ConfD on the
          same host (which can be useful in development scenarios).
        </p><p>
          There are two more instances of ports, network namespaces or VRFs that will have to be
          modified, NETCONF and CLI over SSH. The netconf (SSH and
          TCP) ports that ConfD listens to by default are 2022 and
          2023 respectively, having no defaults for network namespaces and VRF. Modify
          <code class="sgmltag-element">/confdConfig/netconf/transport/ssh</code> and
          <code class="sgmltag-element">/confdConfig/netconf/transport/tcp</code>, either by
          disabling them or changing the ports they listen to, network namespaces or VRF used.
          The CLI over SSH by default listens to 2024; modify
          <code class="sgmltag-element">/confdConfig/cli/ssh</code> either by disabling or
          changing the default port, network namespace or VRF.
        </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e15707"></a>32.5.1.&nbsp;Using a different IPC mechanism</h3></div></div></div><p>
          We can set up ConfD to use a different IPC mechanism than TCP
          for the client library connections, as well as for the
          communication between ConfD nodes in a HA cluster. This can be
          useful e.g. in a chassis system where ConfD runs on a
          management blade, while the managed objects run on data
          processing blades that may not have a TCP/IP implementation.
        </p><p>
          There are several requirements that must be fulfilled by such
          an IPC mechanism:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>It must adhere to the standard socket API, with
            SOCK_STREAM semantics. I.e. it must provide an ordered,
            reliable byte stream, with connection management via the
            <code class="function">connect()</code>, <code class="function">bind()</code>,
            <code class="function">listen()</code>, and <code class="function">accept()</code>
            primitives.</p></li><li class="listitem"><p>It must support non-blocking operations (requested
            via <code class="function">fcntl(O_NONBLOCK)</code>), for
            <code class="function">accept()</code> as well
            as for read and write operations.
            Ideally non-blocking <code class="function">connect()</code> should
            also be supported, but this is not currently used by ConfD
            in this case.</p></li><li class="listitem"><p>It must support the use of <code class="function">poll()</code> for I/O
            multiplexing.</p></li></ul></div><p>
          For ConfD to be able to use this mechanism without knowledge
          of address format etc, we must provide C code in the form of a
          shared object, which is dynamically loaded by ConfD. The
          interface between ConfD and the shared object code is defined
          in the <code class="filename">ipc_drv.h</code> file in the
          <code class="filename">$CONFD_DIR/src/confd/ipc_drv</code> directory in
          the release. The shared object must be named
          <code class="filename">ipc_drv_ops.so</code> and installed in the
          <code class="filename">$CONFD_DIR/lib/confd/lib/core/confd/priv</code>
          directory of the ConfD installation, see the sample Makefile in the
          <code class="filename">ipc_drv</code> directory. The interface is
          implemented via the <code class="function">confd_ext_ipc_init()</code>
          function. This function must be provided by the shared object,
          and it must return a pointer to a callback structure defined
          in the shared object:
        </p><div class="informalexample"><pre class="programlisting">struct confd_ext_ipc_cbs {
    int (*getaddrinfo)(char *address,
                       int *family, int *type, int *protocol,
                       struct sockaddr **addr, socklen_t *addrlen,
                       char **errstr);
    int (*socket)(int family, int type, int protocol, char **errstr);
    int (*getpeeraddr)(int fd, char **address, char **errstr);  /* optional */
    int (*connect)(char *address, char **errstr);
    int (*bind)(char *address, char **errstr);
    void (*unbind)(int fd);                                     /* optional */
};</pre></div><p>
          The structure must provide (i.e. have non-NULL function
          pointers for) either both of the
          <code class="function">getaddrinfo()</code> and
          <code class="function">socket()</code> callbacks, or both of the
          <code class="function">connect()</code> and <code class="function">bind()</code>
          callbacks - it may of course provide all of them. The
          <code class="function">getpeeraddr()</code> and
          <code class="function">unbind()</code> callbacks are optional.
          If both <code class="function">getaddrinfo()</code> and
          <code class="function">socket()</code> are provided, the shared object
          can also be used by applications using the C APIs to connect
          to ConfD (see e.g. the <code class="filename">confd_cmd.c</code> source
          code in the <code class="filename">$CONFD_DIR/src/confd/tools</code>
          directory).
        </p><p>
          All the callbacks except <code class="function">unbind()</code> can
          report an error by returning <code class="constant">-1</code>, and in
          this case optionally provide an error message via the
          <em class="parameter"><code>errstr</code></em> parameter. If an error message
          is provided, <em class="parameter"><code>errstr</code></em> must point to
          dynamically allocated memory - ConfD will free it through a
          call to <code class="function">free(3)</code> after reporting the
          error.
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">getaddrinfo()</span></dt><dd><p>
              This callback should parse the given text-format
              <em class="parameter"><code>address</code></em> (see below). If the parsing
              is successful, the callback should return 0 and provide
              data that can be used for the
              <code class="function">socket()</code> callback and for the standard
              <code class="function">bind(2)</code> and/or
              <code class="function">connect(2)</code> system calls via the
              <em class="parameter"><code>family</code></em>,
              <em class="parameter"><code>type</code></em>,
              <em class="parameter"><code>protocol</code></em>,
              <em class="parameter"><code>addr</code></em>, and
              <em class="parameter"><code>addrlen</code></em> parameters. The structure
              pointed to by <em class="parameter"><code>addr</code></em> must be
              dynamically allocated - ConfD will free it after use
              through a call to <code class="function">free(3)</code>.
            </p></dd><dt><span class="term">socket()</span></dt><dd><p>
              This callback should create a socket, and if successful
              return the socket file descriptor.
            </p></dd><dt><span class="term">getpeeraddr()</span></dt><dd><p>
              This optional callback should create a text representation
              of the address of the remote host/node connected via the
              socket <em class="parameter"><code>fd</code></em>, and if successful return
              0 and provide the text-format address via the
              <em class="parameter"><code>address</code></em> parameter. The main purpose
              of the callback is to make it possible to use the
              <code class="function">maapi_disconnect_remote()</code> function
              (see the <a class="xref" href="rn02re14.html" title="confd_lib_maapi"><span class="refentrytitle">confd_lib_maapi</span>(3)</a>
              manual page), but the provided address will also be used
              in e.g. HA status and notifications, and will be included
              in ConfD debug dumps.
            </p></dd><dt><span class="term">connect()</span></dt><dd><p>
              This callback should create a socket, connect it to the
              given <em class="parameter"><code>address</code></em> (see below), and if
              successful return the socket file descriptor.
            </p></dd><dt><span class="term">bind()</span></dt><dd><p>
              This callback should create a socket, bind it to the given
              <em class="parameter"><code>address</code></em> (see below), and if
              successful return the socket file descriptor.
            </p></dd><dt><span class="term">unbind()</span></dt><dd><p>
              This is an optional callback that can be used if we need
              to do any special cleanup when a bound socket is closed.
              In this case the callback must also close the file
              descriptor - otherwise the function pointer can be set to
              NULL, and ConfD will close the file descriptor.
            </p></dd></dl></div><p>
          Two examples using this interface are provided in the
          <code class="filename">$CONFD_DIR/src/confd/ipc_drv</code>
          directory. One of them (<code class="filename">ipc_drv_unix.c</code>)
          uses AF_UNIX sockets, and implements only the
          <code class="function">connect()</code>, <code class="function">bind()</code>,
          and <code class="function">unbind()</code> callbacks. The other
          (<code class="filename">ipc_drv_etcp.c</code>) actually uses standard
          AF_INET/AF_INET6 TCP sockets just like the "normal" ConfD IPC
          - this can be meaningful if we need to set some non-standard
          socket options such as Linux SO_VRF for all IPC sockets. This
          example implements the <code class="function">getaddrinfo()</code>,
          <code class="function">socket()</code>, and
          <code class="function">getpeeraddr()</code> callbacks.
        </p><p>
          An older version of this interface (also defined in
          <code class="filename">ipc_drv.h</code>) used a
          <code class="function">confd_ipc_init()</code> function and a
          <code class="code">struct confd_ipc_cbs</code> callback structure. This
          interface is deprecated, but will continue to be supported.
          The main differences are that the old interface lacks the
          <code class="function">getaddrinfo()</code>,
          <code class="function">socket()</code>, and
          <code class="function">getpeeraddr()</code> callbacks, and that any
          error message would be provided via a static
          <code class="varname">errstr</code> structure element.
        </p><p>
          To enable the use of this alternate IPC mechanism for the
          client library connections, we need to set
          <code class="sgmltag-element">/confdConfig/confdExternalIpc/enabled</code> to "true" in
          <code class="sgmltag-element">confd.conf</code>. This causes any settings for
          <code class="sgmltag-element">/confdConfig/confdIpcAddress/ip</code> and
          <code class="sgmltag-element">/confdConfig/confdIpcAddress/port</code> to be ignored,
          and we can instead specify the address to use in
          <code class="sgmltag-element">/confdConfig/confdExternalIpc/address</code>. The address
          is given in text form, and ConfD passes it to the
          <code class="function">getaddrinfo()</code>,
          <code class="function">bind()</code>, and/or
          <code class="function">connect()</code> callbacks without any
          interpretation.
        </p><p>
          If we want to use the alternate IPC for the inter-node HA
          communication, we can in the same way set
          <code class="sgmltag-element">/confdConfig/ha/externalIpc/enabled</code> and
          <code class="sgmltag-element">/confdConfig/ha/externalIpc/address</code> in
          <code class="filename">confd.conf</code>. Additionally the HA API uses
          a struct that holds a node address:
        </p><div class="informalexample"><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_ha_node {
    confd_value_t nodeid;
    <strong class="hl-keyword">int</strong> af;               <em class="hl-comment" style="color: silver">/* AF_INET | AF_INET6 | AF_UNSPEC */</em>
    <strong class="hl-keyword">union</strong> {               <em class="hl-comment" style="color: silver">/* address of remote note */</em>
        <strong class="hl-keyword">struct</strong> in_addr ip4;
        <strong class="hl-keyword">struct</strong> in6_addr ip6;
        <strong class="hl-keyword">char</strong> *str;
    } addr;
    <strong class="hl-keyword">char</strong> buf[<span class="hl-number">128</span>];        <em class="hl-comment" style="color: silver">/* when confd_read_notification() and            */</em>
                          <em class="hl-comment" style="color: silver">/* confd_ha_get_status() populate these structs, */</em>
                          <em class="hl-comment" style="color: silver">/* if type of nodeid is C_BUF, the pointer       */</em>
                          <em class="hl-comment" style="color: silver">/* will be set to point into this buffer         */</em>
    <strong class="hl-keyword">char</strong> addr_buf[<span class="hl-number">128</span>];   <em class="hl-comment" style="color: silver">/* similar to the above, but for the address     */</em>
                          <em class="hl-comment" style="color: silver">/* of remote node when using external IPC        */</em>
                          <em class="hl-comment" style="color: silver">/* (from getpeeraddr() callback for secondary    */</em>
                          <em class="hl-comment" style="color: silver">/* nodes)                                        */</em>
};</pre></div><p>
          When this struct is used to specify the address of the primary
          in the <code class="function">confd_ha_besecondary()</code> call, the
          <code class="varname">af</code> element should be set to
          <code class="constant">AF_UNSPEC</code>, and the <code class="varname">str</code>
          element of the <code class="varname">addr</code> union should point to
          the text form of the primary node's address. When the struct is
          used to deliver information from ConfD, in the HA event
          notifications and the result of a
          <code class="function">confd_ha_get_status()</code> call,
          <code class="varname">af</code> will also be set to
          <code class="constant">AF_UNSPEC</code>, but <code class="varname">str</code>
          will be <code class="constant">NULL</code> for secondary nodes unless a
          peer address has been provided via the
          <code class="function">getpeeraddr()</code> callback.
        </p><p>
          The client changes we need to do are analogous to those listed
          in the table above for the case of using a different IP
          address and/or port for TCP - the differences are:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Instead of <code class="varname">CONFD_IPC_ADDR</code> and
            <code class="varname">CONFD_IPC_PORT</code>, the environment variable
            <code class="varname">CONFD_IPC_EXTADDR</code> is used to specify the
            address.  This should be in the same form as used in
            <code class="filename">confd.conf</code>, and if the variable is set
            it causes any <code class="varname">CONFD_IPC_ADDR</code> and
            <code class="varname">CONFD_IPC_PORT</code> settings to be
            ignored.</p></li><li class="listitem"><p>The <span class="command"><strong>confd_cli</strong></span> program also needs to
            be told where to find the shared object that it should use
            for the <code class="function">connect()</code> operation. This is
            done via the <code class="varname">CONFD_IPC_EXTSOPATH</code>
            environment variable, i.e. it typically needs to be set to
            <code class="filename">$CONFD_DIR/lib/confd/lib/core/confd/priv/ipc_drv_ops.so</code>.</p></li><li class="listitem"><p>Provided that the <code class="function">getaddrinfo()</code>
            and <code class="function">socket()</code> callbacks are provided by
            the shared object, the <span class="command"><strong>confd_cmd</strong></span>,
            <span class="command"><strong>confd_load</strong></span>, and <span class="command"><strong>maapi</strong></span>
            commands included in the release can also use the shared
            object if the <code class="varname">CONFD_IPC_EXTSOPATH</code>
            environment variable is set. Otherwise these programs will
            assume that any setting of environment
            <code class="varname">CONFD_IPC_EXTADDR</code> is the pathname of an
            AF_UNIX socket.</p></li></ul></div><p>
          As noted above, <span class="command"><strong>confd_cli</strong></span> is provided as
          source, so we can alternatively modify it to support the
          alternate IPC mechanism "natively". This is also the case for
          <span class="command"><strong>confd_cmd</strong></span>, <span class="command"><strong>confd_load</strong></span>,
          and <span class="command"><strong>maapi</strong></span>.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            If we rebuild <span class="command"><strong>confd_cli</strong></span> or the other
            commands from source, but want to <span class="emphasis"><em>keep</em></span>
            the support for alternate IPC via the environment variables
            and shared object, the preprocessor macro
            <code class="code">EXTERNAL_IPC</code> must be defined. This can be done by
            un-commenting the <code class="code">#define</code> in the source, or by
            using a <span class="command"><strong>-D</strong></span> option to the compiler.
          </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ug.advanced.confd_ipc.restricting"></a>32.5.2.&nbsp;Restricting access to the IPC port</h3></div></div></div><p>
        By default, the clients connecting to the ConfD IPC port are
        considered trusted, i.e. there is no authentication required,
        and we rely on the use of 127.0.0.1 for
        <code class="sgmltag-element">/confdConfig/confdIpcAddress/ip</code> to prevent remote
        access. In case this is not sufficient, it is possible to
        restrict the access to the IPC port by configuring an access
        check.
      </p><p>
        The access check is enabled by setting the
        <code class="filename">confd.conf</code> element
        <code class="sgmltag-element">/confdConfig/confdIpcAccessCheck/enabled</code> to "true",
        and specifying a filename for
        <code class="sgmltag-element">/confdConfig/confdIpcAccessCheck/filename</code>. The file
        should contain a shared secret, i.e. a random character string.
        Clients connecting to the IPC port will then be required to
        prove that they have knowledge of the secret through a challenge
        handshake, before they are allowed access to the ConfD functions
        provided via the IPC port.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        Obviously the access permissions on this file must be restricted
        via OS file permissions, such that it can only be read by the
        ConfD daemon and client processes that are allowed to connect to
        the IPC port. E.g. if both the ConfD daemon and the clients run as
        root, the file can be owned by root and have only "read by
        owner" permission (i.e. mode 0400). Another possibility is to
        have a group that only the ConfD daemon and the clients belong to,
        set the group ID of the file to that group, and have only "read
        by group" permission (i.e. mode 040).
        </p></div><p>
        To provide the secret to the client libraries, and inform them
        that they need to use the access check handshake, we have to set
        the environment variable <code class="code">CONFD_IPC_ACCESS_FILE</code> to the
        full pathname of the file containing the secret. This is
        sufficient for all the clients mentioned above, i.e. there is no
        need to change application code to support or enable this check.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          The access check must be either enabled or disabled for both
          the ConfD daemon and the clients. E.g. if
          <code class="sgmltag-element">/confdConfig/confdIpcAccessCheck/enabled</code> in
          <code class="filename">confd.conf</code> is <span class="emphasis"><em>not</em></span> set
          to "true", but clients are started with the environment
          variable <code class="code">CONFD_IPC_ACCESS_FILE</code> pointing to a file
          with a secret, the client connections will fail.
        </p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e15894"></a>32.6.&nbsp;Restart strategies</h2></div></div></div><p>
        If the ConfD daemon is shut down, all applications connected
        to the ConfD daemon must enter an indefinite reconnect
        loop. If ConfD has been configured to use a startup datastore,
        all applications keeping configuration data in their
        run-time state <span class="emphasis"><em>must</em></span> re-read the configuration data
        from CDB, when the daemon comes back.
      </p><p>
        If ConfD has been setup to <span class="emphasis"><em>not</em></span> use a startup
        datastore, all applications which keep configuration data in
        their run-time state can just proceed its processing without
        any re-read of the configuration data from CDB, when the
        daemon comes back.
      </p><p>
        The ConfD daemon <span class="emphasis"><em>must</em></span> be restarted if .fxs files in a
        running system are to be changed. It is not enough to issue a:
      </p><div class="informalexample"><pre class="screen">$ confd --reload</pre></div><p>
        Before we restart the daemon we need to stop all applications
        relying on the .fxs files that are updated. Whenever the
        daemon is up and running the stopped applications can be
        restarted.
      </p><p>
        Applications which do not rely on the updated .fxs files can
        safely be kept running. However, be sure to follow the startup
        datastore reconnect strategy above.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e15906"></a>32.7.&nbsp;Running ConfD as a non privileged user</h2></div></div></div><p>
        A common misfeature found on UN*X operating systems is the
        restriction that only root can bind to ports below 1024.
        Many a dollar has been wasted on workarounds and
        often the results are security holes.
      </p><p>
        There are a couple of options to overcome this on Linux.
        The first (recommended) is to use Linux <span class="emphasis"><em>capabilities(7)</em></span>,
        namely CAP_NET_BIND_SERVICE. The capability should be set on
        <code class="filename">$CONFD_DIR/lib/confd/erts/bin/confd</code>, this can be done
        using <span class="emphasis"><em>setcap(8)</em></span> command:
        </p><div class="informalexample"><pre class="screen">setcap cap_net_bind_service+eip $CONFD_DIR/lib/confd/erts/bin/confd</pre></div><p>
        and it allows the service to bind to ports below 1024.
      </p><p>
        If it is not desirable to use capabilities, there is another
        way to allow binding to ports lower than 1024 - use an auxiliary program
        like authbind <code class="uri">http://packages.debian.org/stable/authbind</code>
         or privbind <code class="uri">http://sourceforge.net/projects/privbind/</code>
      </p><p>
        These programs are run by root.
        To start confd under e.g authbind we can do:
      </p><div class="informalexample"><pre class="screen">
privbind -u confd /opt/confd/confd-2.7/bin/confd \
    -c /etc/confd.conf
      </pre></div><p>
        The above command starts confd as user <span class="emphasis"><em>confd</em></span>
        and binds to ports below 1024
      </p><p>
      On Linux system to be able to use network namespaces and/or VRF
      (see <a class="xref" href="ch32.html#ug.advanced.confd_ipc" title="32.5.&nbsp;ConfD IPC">Section&nbsp;32.5, &#8220;ConfD IPC&#8221;</a>)
      other capabilities should also be set. Those are CAP_DAC_READ_SEARCH,
      CAP_NET_RAW, CAP_SYS_PTRACE, CAP_SYS_ADMIN. The capabilities should be set
      on the following set of executables:
</p><div class="informalexample"><pre class="screen">$CONFD_DIR/lib/confd/erts/bin/confd.smp
$CONFD_DIR/lib/confd/erts/bin/confdexec
$CONFD_DIR/lib/confd/lib/core/confd/priv/cmdptywrapper
$CONFD_DIR/lib/confd/lib/core/confd/priv/cmdwrapper
</pre></div><p>

      Note that when any Linux capabilities from above are set on ConfD binaries
      the environment variables LD_LIBRARY_PATH and LD_PRELOAD are not honored
      due to security reasons.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e15927"></a>32.8.&nbsp;Storing encrypted values in ConfD</h2></div></div></div><p>
        By using the <code class="code">tailf:des3-cbc-encrypted-string</code>,
        <code class="code">tailf:aes-256-cfb-128-encrypted-string</code> or the
        <code class="code">tailf:aes-cfb-128-encrypted-string</code> built-in types it is
        possible to store encrypted values in ConfD (see
        <a class="xref" href="rn02re15.html" title="confd_types"><span class="refentrytitle">confd_types</span>(3)</a>).
        The keys used to encrypt these values
        are configured in <code class="filename">confd.conf</code>. Whenever an encrypted
        leaf is read using the CDB API or MAAPI it is possible to
        decrypt the returned string using the <code class="code">confd_decrypt()</code>
        function. When the keys in <code class="filename">confd.conf</code> are changed, the
        encrypted values will not be decryptable any longer, so care
        must be taken to re-install the values using the new
        keys. See <a class="xref" href="ch32.html#ug.advanced.replace_encryption_keys" title="32.8.2.&nbsp;Replacing encryption keys in confd.conf">Section&nbsp;32.8.2, &#8220;Replacing encryption keys in confd.conf&#8221;</a>
        for an example on how to do this.
      </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e15938"></a>32.8.1.&nbsp;Reading encryption keys using an external command</h3></div></div></div><p>
          ConfD supports reading encryption keys using an external
          command instead of storing them in confd.conf to allow for
          use with external key management systems. To use this
          feature set
          /confdConfig/encryptedStrings/externalKeys/command to an
          executable command that will output the keys following the
          rules described in the following sections. The command will
          be executed on startup and when ConfD reloads the
          configuration.
        </p><p>
          If the external command fails during startup, the startup
          will abort. If the command fails during a reload the error
          will be logged and the previously loaded keys will be kept
          in the system.
        </p><p>
          The process of providing encryption keys to ConfD can be
          described by the following three steps:

          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Read configuration from environment.</p></li><li class="listitem"><p>Read encryption keys.</p></li><li class="listitem"><p>Write encryption keys or error on standard output.</p></li></ol></div><p>
        </p><p>
          The value of
          /confdConfig/encryptedStrings/externalKeys/commandArgument
          is available in the command as the environment variable
          CONFD_EXTERNAL_KEYS_ARGUMENT. The value of this
          configuration is only used by the configured command.
        </p><p>
          The external command should return the encryption keys on
          standard output using the names as shown in the table
          below. The encryption key values are in hexadecimal format,
          just as in <code class="filename">confd.conf</code>. See the example
          below for details.
        </p><div class="table"><a name="d5e15953"></a><p class="title"><b>Table&nbsp;32.3.&nbsp;
            Mapping from name to path in configuration.
          </b></p><div class="table-contents"><table summary="&#xA;            Mapping from name to path in configuration.&#xA;          " border="1"><colgroup><col width="33%" class="env"><col width="67%" class="path"></colgroup><thead><tr><th>Name</th><th>Configuration path</th></tr></thead><tbody><tr><td>DES3CBC_KEY1</td><td>/confdConfig/encryptedStrings/DES3CBC/key1</td></tr><tr><td>DES3CBC_KEY2</td><td>/confdConfig/encryptedStrings/DES3CBC/key2</td></tr><tr><td>DES3CBC_KEY3</td><td>/confdConfig/encryptedStrings/DES3CBC/key3</td></tr><tr><td>DES3CBC_IV</td><td>/confdConfig/encryptedStrings/DES3CBC/initVector</td></tr><tr><td>AESCFB128_KEY</td><td>/confdConfig/encryptedStrings/AESCFB128/key</td></tr><tr><td>AESCFB128_IV</td><td>/confdConfig/encryptedStrings/AESCFB128/initVector</td></tr><tr><td>AES256CFB128_KEY</td><td>/confdConfig/encryptedStrings/AES256CFB128/key</td></tr></tbody></table></div></div><br class="table-break"><p>
          To signal an error, including ERROR=message is preferred. A
          non-zero exit code or unsupported line content will also
          trigger an error. Any form of error will be logged to the
          development log and no encryption keys will be available in
          the system.
        </p><p>
          Example output providing all supported encryption key
          configuration settings:
          </p><div class="informalexample"><pre class="programlisting">DES3CBC_KEY1=12785c357764a327
DES3CBC_KEY2=30661368c90bc26d
DES3CBC_KEY3=10604b6b63e09310
DES3CBC_IV=f04ab44ed14c3d76
AESCFB128_KEY=2b57c219e47582481b733c1adb84fc26
AESCFB128_IV=549a40ed57629bf6ea64b568f221b515
AES256CFB128_KEY=3c687d564e250ad987198d179537af563341357493ed2242ef3b16a881dd608c</pre></div><p>
        </p><p>
          Example error output:
          </p><div class="informalexample"><pre class="programlisting">ERROR=error message</pre></div><p>
        </p><p>
          Below follows a complete example of an external application
          providing encryption keys from the included example
          external_keys:
          </p><div class="informalexample"><pre class="programlisting">#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

static void error(char *fmt, ...)
{
    va_list ap;

    fprintf(stdout, "ERROR=");
    va_start(ap, fmt);
    vfprintf(stdout, fmt, ap);
    va_end(ap);
    fprintf(stdout, "\n");

    exit(1);
}

static int write_key_file(FILE *fp)
{
    char buf[4069];
    size_t nread;

    do {
        nread = fread(buf, 1, sizeof(buf), fp);
        fwrite(buf, 1, nread, stdout);
    } while (nread == sizeof(buf));

    if (feof(fp)) {
        return 0;
    }
    fprintf(stdout, "\nERROR=key file read error: %s\n", strerror(errno));
    return 1;
}

int main(int argc, char **argv)
{
    const char *key_file = getenv("CONFD_EXTERNAL_KEYS_ARGUMENT");
    if (! key_file) {
        error("CONFD_EXTERNAL_KEYS_ARGUMENT environment not set");
    } else if (! strlen(key_file)) {
        error("CONFD_EXTERNAL_KEYS_ARGUMENT is empty");
    }

    int ret = 0;
    FILE *fp = fopen(key_file, "r");
    if (fp) {
        ret = write_key_file(fp);
        fclose(fp);
    } else {
        error("unable to open %s: %s", key_file, strerror(errno));
    }

    return ret;
}
</pre></div><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ug.advanced.replace_encryption_keys"></a>32.8.2.&nbsp;Replacing encryption keys in confd.conf</h3></div></div></div><p>
          The encrypted values can only be decrypted using
          <code class="code">confd_decrypt()</code>, which only works when ConfD is running
          with the correct keys, so the procedure to update the
          encrypted values is:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Read all the encrypted values and decrypt them</p></li><li class="listitem"><p>Stop the ConfD daemon</p></li><li class="listitem"><p>Restart it with the new encryption keys</p></li><li class="listitem"><p>Write back the values in clear-text, which will cause
          ConfD to encrypt them again</p></li></ol></div><p>
          A very simple YANG model to store encrypted strings could be:
        </p><div class="informalexample"><pre class="programlisting">module enctest {
    namespace "http://www.example.com/ns/enctest";
    prefix e;
    import tailf-common {
        prefix tailf;
    }

    container strs {
        list str {
            key nr;
            max-elements 64;
            leaf nr {
                type int32;
            }
            leaf secret {
                type tailf:aes-cfb-128-encrypted-string;
                mandatory true;
            }
        }
    }
}</pre></div><p>
          Then we could write a function which would read all the
          encrypted leafs and save the clear-text equivalent. Such a
          function (without error checking) could look like this:
        </p><div class="informalexample"><pre class="programlisting">static void install_keys(struct sockaddr_in *addr)
{
    struct confd_daemon_ctx *dctx;
    int ctlsock = socket(PF_INET, SOCK_STREAM, 0);
    dctx = confd_init_daemon(progname);
    confd_connect(dctx, ctlsock, CONTROL_SOCKET, (struct sockaddr*)addr, sizeof (*addr));
    confd_install_crypto_keys(dctx);
    close(ctlsock);
    confd_release_daemon(dctx);
}

static void get_clear_text(struct sockaddr_in *addr, FILE *f)
{
    int rsock = socket(PF_INET, SOCK_STREAM, 0);
    int i, n;

    install_keys(addr);

    cdb_connect(rsock, CDB_READ_SOCKET, (struct sockaddr*)addr, sizeof(*addr));
    cdb_start_session(rsock, CDB_RUNNING);
    cdb_set_namespace(rsock, smp__ns);
    n = cdb_num_instances(rsock, "/strs/str");
    for(i=0; i&lt;n; i++) {
        int nr;
        char cstr[BUFSIZ], dstr[BUFSIZ];

        cdb_get_str(rsock, cstr, sizeof(cstr), "/strs/str[%d]/secret", i);
        cdb_get_int32(rsock, &amp;nr, "/strs/str[%d]/nr", i);
        memset(dstr, 0, sizeof(dstr));
        confd_decrypt(cstr, strlen(cstr), dstr);
        fprintf(f, "/strs/str{%d}/secret=$0$%s\n", nr, dstr);
    }
    cdb_end_session(rsock),
    cdb_close(rsock);
}</pre></div><p>
          Note the prefixing of the clear-text output of <code class="code">$0$</code> -
          this indicates to the ConfD daemon that the strings
          are in clear text, causing it to encrypt them when we install
          them again.
        </p><p>
          Now the opposite function, reading lines of the form
          <code class="code">"keypath=value"</code> and using the <code class="code">maapi_set_elem2()</code>
          function to write them back to the ConfD daemon.
        </p><div class="informalexample"><pre class="programlisting">static void set_values(struct sockaddr_in *addr, FILE *f)
{
    int msock = socket(PF_INET, SOCK_STREAM, 0);
    int th;
    struct confd_ip ip;
    const char *groups[] = { "admin" };

    maapi_connect(msock, (struct sockaddr*)addr, sizeof(*addr));
    ip.af = AF_INET;
    inet_aton("127.0.0.1", &amp;ip.ip.v4);
    maapi_start_user_session(msock, "admin", progname,
                             groups, sizeof(groups) / sizeof(*groups),
                             &amp;ip, CONFD_PROTO_TCP);

    maapi_start_trans(msock, CONFD_RUNNING, CONFD_READ_WRITE);
    maapi_set_namespace(msock, th, smp__ns);
    for (;;) {
        char *key, *val, line[BUFSIZ];
        if (fgets(line, sizeof(line), f) == NULL) {
            break;
        }
        key = line;
        val = strchr(key, (int)'=');
        *val++ = 0; /* NUL terminate the key, make val point to value */
        maapi_set_elem2(msock, th, val, key);
    }
    maapi_apply_trans(msock, th, 0);
    maapi_end_user_session(msock);
    close(msock);
}</pre></div><p>
          Putting it together with this <code class="code">main()</code> function makes a
          useful utility program for the task at hand.
        </p><div class="informalexample"><pre class="programlisting">int main(int argc, char **argv)
{
    char *confd_addr = "127.0.0.1";
    int confd_port = CONFD_PORT;
    struct sockaddr_in addr;
    int c, mode = 0;            /* 1 = get, 2 = set */

    /* Parse command line */
    while ((c = getopt(argc, argv, "gs")) != EOF) {
        switch (c) {
        case 'g':
            mode = 1;
            break;
        case 's':
            mode = 2;
            break;
        default:
            printf("huh?\n");
            exit(1);
        }
    }
    if (!mode) {
        fprintf(stderr, "%s: must provide either -s or -g\n", argv[0]);
        exit(1);
    }
    /* Initialize address to confd daemon */
    {
        struct in_addr in;
        inet_aton(confd_addr, &amp;in);
        addr.sin_addr.s_addr = in.s_addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(confd_port);
    }
    confd_init(argv[0], stderr, dbg);

    switch (mode) {
    case 1: get_clear_text(&amp;addr, stdout); break;
    case 2: set_values(&amp;addr, stdin); break;
    }
    exit(0);
}</pre></div><p>
          Using this utility, called <span class="command"><strong>crypto_keys</strong></span>,
          installing new encryption keys could be done using a shell
          script like this.
        </p><div class="informalexample"><pre class="screen"># First save clear text version of the keys in a temporary file
crypto_keys -g &gt; TOP_SECRET

# Now stop the daemon
confd --stop

# Install the new AES encryption key (provided to this script in $1)
mv confd.conf confd.conf.old
xmlset C "$1" confdConfig encryptedStrings AESCFB128 key &lt; \
    confd.conf.old  &gt; confd.conf
rm -f confd.conf.old

# Bring the daemon up to start-phase 1
confd -c confd-conf --start-phase0
confd --start-phase1

# Now write back the keys, and remove the temporary file
crypto_keys -s &lt; TOP_SECRET
rm -f TOP_SECRET

# We are done
confd --start-phase2</pre></div><p>
          In this example we are only using AES encryption, and only
          modifying the key, not the initial vector - but it is easy to
          extend to use the 3DES keys as well. The <span class="command"><strong>xmlset</strong></span> utility
          (provided as example source in <code class="filename">$CONFD_DIR/src/confd/tools</code>) in the
          ConfD distribution) is used to modify the key in
          <code class="filename">confd.conf</code>. Writing back the encrypted leaf in
          start phase 1 ensures that no external method (e.g. a NETCONF
          request) modifies the data before it is re-installed with the
          new encryption keys.
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.disaster"></a>32.9.&nbsp;Disaster management</h2></div></div></div><p>
        This section describes a number of disaster scenarios and
        recommends various actions to take in the different disaster
        variants.
      </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16035"></a>32.9.1.&nbsp;ConfD fails to start</h3></div></div></div><p>
          CDB keeps its data in two files <code class="filename">A.cdb</code> and
          <code class="filename">C.cdb</code>. If ConfD is stopped, these two files can
          simply be copied, and the copy is then a full backup of
          CDB. If ConfD is running, we cannot copy the files, but need
          to use <span class="command"><strong>confd --cdb-backup file</strong></span> to copy the two CDB
          files into a backup file (in gzipped tar format).
        </p><p>
          Furthermore, if neither A.cdb nor C.cdb exists in the
          configured CDB directory, CDB will attempt to initialize
          from all files in the CDB directory with the suffix ".xml".
        </p><p>
          Thus, there exists two different ways to reinitiate CDB from
          a previous known good state, either from .xml files of from
          a CDB backup. The .xml files would typically be used to
          reinstall "factory defaults" whereas a CDB backup could be
          used in more complex scenarios.
        </p><p>
          When ConfD starts and fails to initialize, the following
          exit codes can occur:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Exit codes <span class="emphasis"><em>1</em></span> and
            <span class="emphasis"><em>19</em></span> mean that an internal
            error has occurred. A text message should be in the logs, or
            if the error occurred at startup before logging had been
            activated, on standard error (standard output if ConfD was
            started with --foreground). Generally the message will only
            be meaningful to the ConfD developers, and an internal error
            should always be reported to Cisco support.</p></li><li class="listitem"><p>Exit codes <span class="emphasis"><em>2</em></span> and
            <span class="emphasis"><em>3</em></span> are only used for the confd "control
            commands" (see the section COMMUNICATING WITH CONFD in the
            <a class="xref" href="rn01re01.html" title="confd"><span class="refentrytitle">confd</span>(1)</a> manual page), and mean
            that the command failed due to timeout. Code
            <span class="emphasis"><em>2</em></span> is used when the initial connect to
            ConfD didn't succeed within 5 seconds (or the
            <code class="option">TryTime</code> if given), while code
            <span class="emphasis"><em>3</em></span> means that the ConfD daemon did not
            complete the command within the time given by the
            <code class="option">--timeout</code> option.</p></li><li class="listitem"><p>Exit code <span class="emphasis"><em>10</em></span> means that one of the init
            files in the CDB directory was faulty in some way. For further
            information, see the log.</p></li><li class="listitem"><p>Exit code <span class="emphasis"><em>11</em></span> means that the CDB configuration was
            changed in an unsupported way. This will only happen when
            an existing database is detected, which was created
            with another configuration than the current in confd.conf.</p></li><li class="listitem"><p>Exit code <span class="emphasis"><em>12</em></span> means that the C.cdb file is in an
            old and unsupported format (this can only happen if the
            CDB database was created with a ConfD version older than
            1.3, from which upgrading isn't supported).</p></li><li class="listitem"><p>Exit code <span class="emphasis"><em>13</em></span> means that the schema change
            caused an upgrade, but for some reason the upgrade
            failed. Details are in the log. The way to recover from
            this situation is either to correct the problem or to
            re-install the old schema (fxs) files.</p></li><li class="listitem"><p> Exit code <span class="emphasis"><em>14</em></span> means that the schema change
            caused an upgrade, but for some reason the upgrade failed,
            corrupting the database in the process. This is rare and
            usually caused by a bug. To recover, either start from an
            empty database with the new schema, or re-install the old
            schema files and apply a backup.
            </p></li><li class="listitem"><p>Exit code <span class="emphasis"><em>15</em></span> means that <code class="filename">A.cdb</code> or
            <code class="filename">C.cdb</code> is corrupt in a non-recoverable way. Remove
            the files and re-start using a backup or init files.</p></li><li class="listitem"><p>Exit code <span class="emphasis"><em>16</em></span> means that CDB ran
            into an unrecoverable file-error (such as
            running out of space on the device while writing the
            initial schema file).</p></li><li class="listitem"><p>Exit code <span class="emphasis"><em>20</em></span> means that ConfD failed to
            bind a socket. By default this means that Confd refuses to start.
            It is however possible to force Confd to ignore this fatal
            error situation by enabling the parameter
            <span class="emphasis"><em>/confdConfig/ignoreBindErrors</em></span>. Instead
            a warning is issued and the failing northbound agent is disabled.
            The agent may be enabled by dynamically re-configuring the
            failing agent to use another port and restart Confd.</p></li><li class="listitem"><p>Exit code <span class="emphasis"><em>21</em></span> means that some ConfD
            configuration file is faulty. More information in the logs.</p></li><li class="listitem"><p>Exit code <span class="emphasis"><em>22</em></span> indicates a ConfD
            installation related problem, e.g. that the user does not
            have read access to some library files, or that some file
            is missing.</p></li></ul></div><p>
          If the ConfD daemon starts normally, the exit code is
          <span class="emphasis"><em>0</em></span>.
        </p><p>
          If CDB is reinitialized to factory defaults, it may not be
          possible to reach the machine over the network.  The only
          way to reconfigure the machine is through a CLI login over
          the serial console.
        </p><p>
          If the AAA database is broken, ConfD will start but with no
          authorization rules loaded. This means that all write access to
          the configuration is denied.  The ConfD CLI can be
          started with a flag <span class="command"><strong>confd_cli --noaaa</strong></span> which will
          allow full unauthorized access to the configuration.  Usage
          of the ConfD cli with this flag can possibly be enabled for
          some special UNIX user which can only login over the serial
          port. Thus <span class="command"><strong>--noaaa</strong></span> provides a way to reconfigure the
          box although the AAA database is broken.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16097"></a>32.9.2.&nbsp;ConfD failure after startup</h3></div></div></div><p>
          ConfD attempts to handle all runtime problems without
          terminating, e.g. by restarting specific components.
          However there are some cases where this is not possible,
          described below. When ConfD is started the default way,
          i.e. as a daemon, the exit codes will of course not be
          available, but see the --foreground option in the
          <span class="emphasis"><em>confd(1)</em></span> manual page.
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Out of memory: If ConfD is unable to allocate memory, it will
            exit by calling <span class="emphasis"><em>abort(3)</em></span>. This will generate an
            exit code as for reception of the SIGABRT signal - e.g. if ConfD
            is started from a shell script, it will see 134 as exit code
            (128 + the signal number).</p></li><li class="listitem"><p>Out of file descriptors for <span class="emphasis"><em>accept(2)</em></span>: If ConfD fails
            to accept a TCP connection due to lack of file descriptors,
            it will log this and then exit with code 25. To avoid this
            problem, make sure that the process and system-wide file
            descriptor limits are set high enough, and if needed configure
            session limits in <code class="filename">confd.conf</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                The out-of-file descriptors issue may also manifest itself in
                that applications are no longer able to open new file
                descriptors.
              </p></div><p>
              In many Linux systems the default limit is 1024, but if we,
              for example, assume that there are 4 northbound interface ports,
              CLI, RESTCONF, SNMP, WebUI/JSON-RPC, or similar, plus a few
              hundreds of IPC ports, x 1024 == 5120. But one might as well use
              the next power of two, 8192, to be on the safe side.
            </p><p>
              Several application issues can contribute to consuming extra
              ports. In the scope of a ConfD application that could, for
              example, be a script application that invokes CLI command or a
              callback daemon application that does not close the connection
              socket as they should.
            </p><p>
              A commonly used command for changing the maximum number of open
              file descriptors is <span class="command"><strong>ulimit -n [limit]</strong></span>.
              Commands such as <span class="command"><strong>netstat</strong></span> and
              <span class="command"><strong>lsof</strong></span> can be useful to debug file descriptor
              related issues.
            </p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16117"></a>32.9.3.&nbsp;Transaction commit failure</h3></div></div></div><p>
          When the system is updated, ConfD executes a two phase
          commit protocol towards the different participating
          databases including CDB. If a participant fails in the
          <code class="code">commit()</code> phase although the participant succeeded in the
          prepare phase, the configuration is possibly in an
          inconsistent state.
        </p><p>
          When ConfD considers the configuration to be in a
          inconsistent state, operations will continue. It is still
          possible to use NETCONF, the CLI and all other northbound
          management agents. The CLI has a different prompt which
          reflects that the system is considered to be in an
          inconsistent state and also the Web UI shows this:
        </p><div class="informalexample"><pre class="screen">
  -- WARNING ------------------------------------------------------
  Running db may be inconsistent. Enter private configuration mode and
  install a rollback configuration or load a saved configuration.
  ------------------------------------------------------------------
        </pre></div><p>
          It is slightly more involved using the NETCONF agent. The
          NETCONF transaction which resulted in a failed commit will
          fail, but following that the only way to see that the system
          is considered to be in an inconsistent state is by reading
          the data defined by <span class="emphasis"><em>tailf-netconf-monitoring</em></span>.
        </p><p>
          The MAAPI API has two interface functions which can be used
          to set and retrieve the consistency status, those are
          <code class="function">maapi_set_running_db_status()</code> and
          <code class="function">maapi_get_running_db_status()</code>
          corresponding. This API can thus be used to manually reset
          the consistency state. The only alternative to reset the state
          to a consistent state is by reloading the entire configuration.
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e16129"></a>32.10.&nbsp;Troubleshooting</h2></div></div></div><p>
        This section discusses problems that new users have seen when
        they started to use ConfD.  Please do not hesitate to contact
        our support team (see below) if you are having trouble,
        regardless of whether your problem is listed here or not.
      </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16132"></a>32.10.1.&nbsp;Installation Problems</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d5e16134"></a>Error messages during installation</h4></div></div></div><p>The installation program gives a lot of error
          messages, the first few like the ones below. The resulting
          installation is obviously incomplete.</p><div class="informalexample"><pre class="screen">tar: Skipping to next header
gzip: stdin: invalid compressed data--format violated</pre></div><p>Cause: This happens if the installation program has
          been damaged, most likely because it has been downloaded in
          'ascii' mode.</p><p>Resolution: Remove the installation
          directory. Download a new copy of ConfD from our servers.
          Make sure you use binary transfer mode every step of the
          way.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16141"></a>32.10.2.&nbsp;Problems Starting ConfD</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d5e16143"></a>ConfD terminating with GLIBC error</h4></div></div></div><p>ConfD terminates immediately with a message similar to
          the one below.</p><div class="informalexample"><pre class="screen">/.../lib/confd/erts/bin/confdexec: /lib/x86_64-linux-gnu/libc.so.6:
version `GLIBC_2.14' not found (required by
/.../lib/confd/erts/bin/confdexec)</pre></div><p>Cause: This happens if you are running on a Linux version where
          the GNU libc (GLIBC) version is older than what is supported by
          ConfD, in the example above older than GLIBC version 2.14.</p><p>Resolution: Use a newer Linux system, or upgrade the
          GLIBC installation.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d5e16150"></a>ConfD terminating with libcrypto error</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ConfD terminates immediately with a message similar
              to this:</p><div class="informalexample"><pre class="screen">Bad configuration: .../confd.conf:0: cannot dynamically link with
libcrypto shared library</pre></div><p>Cause: This normally happens due to the OpenSSL
              package being of the wrong version or not installed in the
              operating system.</p><p>Resolution: One of</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Install the OpenSSL package with the correct
                  version. This is 1.1.1 for Linux releases of ConfD.
                  To find out the version to install, run:</p><div class="informalexample"><pre class="screen">$ ldd $CONFD_DIR/lib/confd/lib/core/crypto/priv/lib/crypto.so</pre></div><p>Note: only the libcrypto shared library
                  (libcrypto.so.N.N.N) is actually required by
                  ConfD.</p></li><li class="listitem"><p>Provided that a different version of OpenSSL,
                  1.0.0 or greater, is installed: Rebuild the ConfD
                  components that depend on libcrypto to use this
                  version, as described in <a class="xref" href="ch32.html#ug.advanced.different_openssl" title="32.14.&nbsp;Using a different version of OpenSSL and optionally activating FIPS">Section&nbsp;32.14, &#8220;Using a different version of OpenSSL and optionally
    activating FIPS&#8221;</a>.</p></li></ol></div></li></ul></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16168"></a>32.10.3.&nbsp;Problems Running Examples</h3></div></div></div><p>
            Some examples are dependent on features that might only be available
            on Linux. Before such examples can run, they would have to
            be ported.
          </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="d5e16171"></a>The 'netconf-console' program fails</h4></div></div></div><p>
                Sending NETCONF commands and queries with
                'netconf-console' fails, while it works using
                'netconf-console-tcp'.  The error message is below.
              </p><p>
                You must install the python ssh implementation paramiko in order
                to use ssh.
              </p><p>
                Cause: The netconf-console command is implemented using the
                Python programming language. It depends on the Python SSH
                implementation Paramiko. Since you are seeing this message,
                your operating system doesn't have the python-module Paramiko
                installed. The Paramiko package, in turn, depends on a few
                other Python packages.
              </p><p>
                Resolution: Install Paramiko and its dependencies
                using the standard installation mechanisms
                for your OS. An alternative approach is to go to the
                project home pages to fetch, build and install the
                missing packages.
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://www.paramiko.org/" target="_top">https://www.paramiko.org/</a></p></li></ul></div><p>
                These packages come with simple installation
                instructions. You will need root privileges to install
                these packages, however.  When properly installed, you
                should be able to import the paramiko module without
                error messages
              </p><div class="informalexample"><pre class="screen">$ python
...
&gt;&gt;&gt; import paramiko
&gt;&gt;&gt;</pre></div><p>Exit the Python interpreter with Ctrl+D.</p><p>
                A workaround is to use 'netconf-console-tcp'. It uses
                TCP instead of SSH and doesn't require Paramiko or
                Pycrypto. Note that TCP traffic is not encrypted.
              </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16186"></a>32.10.4.&nbsp;General Troubleshooting Strategies</h3></div></div></div><p>
            If you have trouble starting or running ConfD, the
            examples or the clients you write, here are some
            troubleshooting tips.
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Transcript</span></dt><dd><p>
              When contacting support, it often helps the support
              engineer to understand what you are trying to achieve if
              you copy-paste the commands, responses and shell scripts
              that you used to trigger the problem.</p></dd><dt><span class="term">Verbose flag</span></dt><dd><p>
              When ConfD is started, give the --verbose (abbreviated
              -v) and --foreground flags. This will prevent ConfD from
              starting as a daemon and cause some messages to be printed
              on the stdout.
              </p><div class="informalexample"><pre class="screen">
$ confd --verbose --foreground ...
              </pre></div><p>
            </p></dd><dt><span class="term">Log files</span></dt><dd><p>
              To find out what ConfD is/was doing, browsing ConfD's
              log files is often helpful.  In the examples, they are
              called 'devel.log', 'confd.log', 'audit.log' and
              'confd.log'.  If you are working with your own system,
              make sure the log files are enabled in 'confd.conf'.
              They are already enabled in all the examples.</p></dd><dt><span class="term">Status</span></dt><dd><p>
              ConfD will give you a comprehensive status report if you
              call
              </p><div class="informalexample"><pre class="screen">
$ confd --status
              </pre></div><p>
            </p><p>
              ConfD status information is also available as operational
              data under <code class="sgmltag-element">/confd-state</code> when the
              <code class="filename">tailf-confd-monitoring.fxs</code> and
              <code class="filename">tailf-common-monitoring.fxs</code> data
              model files are present in ConfD's <code class="sgmltag-element">loadPath</code>.
              These files are stored in
              <code class="filename">$CONFD_DIR/etc/confd</code> in the ConfD
              release, and the functionality thus enabled by default.
              See the corresponding YANG modules
              <code class="filename">tailf-confd-monitoring.yang</code> and
              <code class="filename">tailf-common-monitoring.yang</code> in the
              <code class="filename">$CONFD_DIR/src/confd/yang</code> directory
              of the ConfD release for documentation of the provided
              data. To allow programmatic access to this data via
              MAAPI without exposing it to end users, the modules can be
              recompiled with the <code class="option">--export none</code> option
              to <span class="command"><strong>confdc</strong></span> (see <a class="xref" href="rn01re03.html" title="confdc"><span class="refentrytitle"><span class="phrase">confdc</span>
    </span>(1)</a>).
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
              When recompiling these modules, it is critical that the
              annotation module
              <code class="filename">tailf-confd-monitoring-ann.yang</code> is
              used, see
              <code class="filename">$CONFD_DIR/src/confd/yang/Makefile</code>.
            </p></div></dd><dt><span class="term">Check data provider</span></dt><dd><p>
              If you are implementing a data provider (for operational or
              configuration data), you can verify that it works for all possible
              data items using
              </p><div class="informalexample"><pre class="screen">
$ confd --check-callbacks
</pre></div><p>
            </p></dd><dt><span class="term">Debug dump</span></dt><dd><p>
              If you suspect you have experienced a bug in ConfD, or
              ConfD told you so, you can give Support a debug dump to
              help us diagnose the problem. It contains a lot of
              status information (including a full confd --status
              report) and some internal state information. This
              information is only readable and comprehensible to the
              ConfD development team, so send the dump to your support
              contact. A debug dump is created using
              </p><div class="informalexample"><pre class="screen">
$ confd --debug-dump mydump1
              </pre></div><p>

              Just as in CSI on TV, it's important that the
              information is collected as soon as possible after the
              event. Many interesting traces will wash away with time,
              or stay undetected if there are lots of irrelevant facts
              in the dump.</p><p>
                If ConfD gets stuck while terminating, it can optionally
                create a debug dump after being stuck for 60 seconds.
                To enable this mechanism, set the environment variable
                <code class="varname">$CONFD_DEBUG_DUMP_NAME</code> to a filename
                of your choice.
              </p><p>
                During the creation of debug dump for large system, some
                information can reach timeout and thus can be truncated in debug
                dump. In that case, ConfD will inform client by following
                message:
                </p><div class="informalexample"><pre class="screen">
*** Failed to collect &lt;type&gt;: timeout
                 </pre></div><p>
              </p><p>
                Client can extend the timeout by using the option
                <code class="code">--collect-timeout &lt;seconds&gt;</code>. The
                default timeout is 10 seconds.
              </p><p>
                Client can compress the debug dump by using the option
                <code class="code">--compress</code>. In that case, the debug dump
                will be compressed to <code class="code">mydump1.gz</code>.
              </p></dd><dt><span class="term">Debug error log</span></dt><dd><p>
              Another thing you can do if you suspect you have
              experienced a bug in ConfD, is to enable the error log.
              The logged information is only readable and
              comprehensible to the ConfD development team, so send
              the log to your support contact.
              </p><p>
                By default, the error log is disabled.  To enable it, add this
                chunk of XML between <code class="code">&lt;logs&gt;</code> and
                <code class="code">&lt;/logs&gt;</code> in your
                <code class="filename">confd.conf</code> file:
                </p><div class="informalexample"><pre class="programlisting">
&lt;errorLog&gt;
  &lt;enabled&gt;true&lt;/enabled&gt;
  &lt;filename&gt;./error.log&lt;/filename&gt;
&lt;/errorLog&gt;
                </pre></div><p>

                This will actually create a number of files called
                ./error.log*. Please send them all to us.
              </p></dd><dt><span class="term">System dump</span></dt><dd><p>
              If ConfD aborts due to failure to allocate memory
              (see <a class="xref" href="ch32.html#ug.advanced.disaster" title="32.9.&nbsp;Disaster management">Section&nbsp;32.9, &#8220;Disaster management&#8221;</a>), and you
              believe that this is due to a memory leak in ConfD,
              creating one or more debug dumps as described above
              (before ConfD aborts) will produce the most useful
              information for Support. If this is not possible,
              you can make ConfD produce a system dump just before
              aborting. To do this, set the environment variable
              <code class="varname">$CONFD_DUMP</code> to a file name for the dump
              before starting ConfD. The dumped information is only
              comprehensible to the ConfD development team, so send
              the dump to your support contact.
            </p></dd><dt><span class="term">System call trace</span></dt><dd><p>
                To catch certain types of problems, especially
                relating to system start and configuration, the
                operating system's system call trace can be
                invaluable.  This tool is called strace/ktrace/truss.
                Please send the result to your support contact for a
                diagnosis.  Running instructions below.
              </p><p>Linux:</p><div class="informalexample"><pre class="screen">
$ strace -f -o mylog1.strace -s 1024 confd ...
              </pre></div><p>BSD:</p><div class="informalexample"><pre class="screen">
$ ktrace -ad -f mylog1.ktrace confd ...
$ kdump -f mylog1.ktrace &gt; mylog1.kdump
              </pre></div><p>Solaris:</p><div class="informalexample"><pre class="screen">
$ truss -f -o mylog1.truss confd ...
              </pre></div></dd><dt><span class="term">Application debugging</span></dt><dd><p>
                The primary tool for debugging the interaction between
                applications and ConfD is to give the debug level
                <em class="parameter"><code>debug</code></em> to
                <code class="function">confd_init()</code> as
                <code class="constant">CONFD_TRACE</code>, see the <a class="xref" href="rn02re13.html" title="confd_lib_lib"><span class="refentrytitle">confd_lib_lib</span>(3)</a> manual page.  If
                more in-depth debugging using e.g.
                <span class="command"><strong>gdb</strong></span> is needed, it may be useful to
                rebuild the <code class="filename">libconfd</code> library from
                source with debugging symbols. This can be done by using
                the libconfd source package
                <code class="filename">confd-&lt;vsn&gt;.libconfd.tar.gz</code>
                that is delivered with the ConfD release. The package
                includes a <code class="filename">README</code> file that
                describes how to do the build - note in particular the
                "Application debugging" section.
              </p><p>
                When debugging application memory leaks with a tool like
                <span class="command"><strong>valgrind</strong></span>, it is often
                <span class="emphasis"><em>necessary</em></span> to rebuild libconfd from
                source, since the default build uses a "pool allocator"
                that makes the stack trace information for memory leaks
                from <span class="command"><strong>valgrind</strong></span> completely misleading
                for allocations from libconfd. The details of how to do
                a build that disables the pool allocator are described
                in the "Application debugging" section of the
                <code class="filename">README</code> in the libconfd source
                package.
              </p></dd></dl></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e16294"></a>32.11.&nbsp;Tuning the size of confd_hkeypath_t</h2></div></div></div><p>The ConfD C API library <code class="filename">libconfd</code> uses a
    C struct for passing keypaths to callback functions:</p><div class="informalexample"><pre class="programlisting"><strong class="hl-keyword">typedef</strong> <strong class="hl-keyword">struct</strong> confd_hkeypath {
    <strong class="hl-keyword">int</strong> len;
    confd_value_t v[MAXDEPTH][MAXKEYLEN];
} confd_hkeypath_t;</pre></div><p>See <a class="xref" href="rn02re15.html#man.3.confd_types.xml_paths" title="XML PATHS">the section called &#8220;XML PATHS&#8221;</a> in the
    <a class="xref" href="rn02re15.html" title="confd_types"><span class="refentrytitle">confd_types</span>(3)</a> manual page for discussion
    about how this struct is used. The values used for
    <code class="constant">MAXDEPTH</code> and <code class="constant">MAXKEYLEN</code> are
    20 and 9, respectively, which should be big enough even for very
    large and complex data models. However this comes at a cost in
    memory (mainly stack) usage - the size of a confd_hkeypath_t is
    approximately 5.5 kB. Also, in some rare cases, we may have a data
    model where one or both of these values are not large enough.</p><p>It is possible to use other values for
    <code class="constant">MAXDEPTH</code> and <code class="constant">MAXKEYLEN</code>,
    but this requires both that <code class="filename">libconfd</code> is rebuilt
    from source with the new values, and that all applications that use
    <code class="filename">libconfd</code> are also compiled with the new values.
    It is of course possible to just edit <code class="filename">confd_lib.h</code>
    with the new values, but the <code class="code">#define</code> statements for
    these in <code class="filename">confd_lib.h</code> are guarded with
    <code class="code">#ifndef</code> directives, which means that they can
    alternatively be overridden without changing
    <code class="filename">confd_lib.h</code>.</p><p>Overriding can be done either via <code class="option">-D</code> options
    on the compiler command line, or via <code class="code">#define</code> statements
    before the <code class="code">#include</code> for <code class="filename">confd_lib.h</code>.
    For building <code class="filename">libconfd</code> itself without source
    changes, only the <code class="option">-D</code> option method is possible,
    though. The build procedure supports an
    <code class="varname">EXTRA_CFLAGS</code> <span class="command"><strong>make</strong></span> variable
    that can be used this purpose, see the <code class="filename">README</code>
    file included in the libconfd source package. E.g. we can do the
    <code class="filename">libconfd</code> build with:</p><div class="informalexample"><pre class="screen">$ make EXTRA_CFLAGS="-DMAXDEPTH=10 -DMAXKEYLEN=5"</pre></div><p>The <code class="option">-D</code> option method can of course be used
    when building applications too, but it is probably less error-prone
    to use the <code class="code">#define</code> method. E.g. if we make sure that
    none of the application C or C++ files include
    <code class="filename">confd_lib.h</code> (or
    <code class="filename">confd.h</code>) directly, but instead include say
    <code class="filename">app.h</code>, we can have this in
    <code class="filename">app.h</code>:</p><div class="informalexample"><pre class="programlisting">#define MAXDEPTH 10
#define MAXKEYLEN 5
#include &lt;confd_lib.h&gt;
      </pre></div><p>Whenever an application connects to ConfD via one of the API
    functions (i.e. <code class="function">confd_connect()</code>,
    <code class="function">cdb_connect()</code>, etc), a check is made that the
    <code class="constant">MAXDEPTH</code> and <code class="constant">MAXKEYLEN</code>
    values used for building the library are large enough for the data
    models loaded into ConfD. If they are not, the connection will fail
    with <code class="varname">confd_errno</code> set to
    <code class="constant">CONFD_ERR_PROTOUSAGE</code> and
    <code class="function">confd_lasterr()</code> giving a message with the
    required minimum values. Whether the connection succeeds or not, the
    library will also set the global variables
    <code class="varname">confd_maxdepth</code> and
    <code class="varname">confd_maxkeylen</code> to the minimum values required by
    ConfD. Thus the values can be found by simply printing these
    variables in any application that connects to ConfD.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e16347"></a>32.12.&nbsp;Configuring NETCONF receive buffer size</h2></div></div></div><p>The internal implementation of SSH server allocates buffers
    to store packets received from the peer but not yet processed by NETCONF.
    One buffer stores the raw data from SSH and the other buffer stores the
    data converted from binary representation into text (which is later consumed
    by NETCONF).
    When the size of RPCs sent over NETCONF is big the memory for
    the first buffer is reallocated often which can lead to memory usage spike and
    sometimes cause ConfD to fail due to the out-of-memory condition. Also the
    text representation of binary data can take significant amount of memory,
    also leading to the out-of-memory condition.</p><p>To mitigate such failures it is possible to configure buffer sizes.
    For the first buffer (for raw data) the size can be configured
    by changing the value of <code class="sgmltag-element">/confdConfig/netconf/transport/ssh/rcvPktSize</code>
    in <code class="filename">confd.conf</code>.
    The parameter value determines the single SSH packet size and the buffer
    size is calculated to hold several packets.
    For the second buffer (for NETCONF data as text) the size can be set
    by configuring the <code class="sgmltag-element">/confdConfig/netconf/transport/ssh/ncChunkSize</code>
    parameter in <code class="filename">confd.conf</code>.
    The value determines the size (in bytes) of the amount of unprocessed text data that
    can be stored.</p><p>Note that the values are not reconfigurable in runtime.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.custom.msgs"></a>32.13.&nbsp;Error Message Customization</h2></div></div></div><p>
      The ConfD release includes a XML document,
      <code class="filename">$CONFD_DIR/src/confd/errors/errcode.xml</code>, that
      specifies all the customizable errors that may be reported in the
      different northbound interfaces. The errors are classified with a
      type and a code, and for each error a parameterized format string
      for the default error message is given.
    </p><p>
      The purpose of this file is both to serve as a reference list of
      the possible errors, which could e.g. be processed
      programmatically when generating end-user documentation, and to
      provide the basis for error message customization.
    </p><p>
      All the error messages specified in the file can be customized by
      means of application callbacks. An application can register a
      callback for one or more of the error types, and whenever an error
      is to be reported in a northbound interface, the callback will
      first be invoked and given the opportunity to return a message
      that is different from the default.
    </p><p>
      The callback will receive user session information, the error type
      and code, the default error message, and the parameters used to
      create the default message. For errors of type "validation", the
      callback also has access to the contents of the transaction that
      failed validation. See <a class="xref" href="rn02re10.html#man.3.confd_lib_dp.error_formatting_callback" title="ERROR FORMATTING CALLBACK">the section called &#8220;ERROR FORMATTING CALLBACK&#8221;</a> in
      the <a class="xref" href="rn02re10.html" title="confd_lib_dp"><span class="refentrytitle">confd_lib_dp</span>(3)</a> manual page for the
      details of the callback registration and invocation.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.different_openssl"></a>32.14.&nbsp;Using a different version of OpenSSL and optionally
    activating FIPS</h2></div></div></div><p>
      ConfD depends on the OpenSSL <code class="filename">libcrypto</code> shared
      library for a number of cryptographic functions.  (The
      <code class="filename">libssl</code> library is not used by ConfD.)
      Currently ConfD releases are built with OpenSSL version 1.1.1, and thus
      require that the <code class="filename">libcrypto</code> library from this
      version is present when ConfD is run.
    </p><p>
      However the <code class="filename">libcrypto</code> dependency is limited
      to two components in the ConfD release, the
      <code class="filename">libconfd</code> library used by applications, and a
      shared object called <code class="filename">crypto.so</code>, that is used
      by the ConfD daemon as an interface to
      <code class="filename">libcrypto</code>. Both these components are
      included in source form in the
      <code class="filename">confd-&lt;vsn&gt;.libconfd.tar.gz</code> tar archive
      that is provided with each ConfD release.
    </p><p>
      To use a different OpenSSL version than the one the ConfD release
      is built with, it is sufficient to use the provided sources to rebuild
      these two components with the desired OpenSSL version, and replace
      them in the ConfD release. The toplevel README file included in
      the tar archive has instructions on how to do the build of both
      <code class="filename">libconfd</code> and <code class="filename">crypto.so</code>.
    </p><p>
      While <code class="filename">libconfd</code> can be located wherever it is
      convenient for application use, <code class="filename">crypto.so</code>
      <span class="emphasis"><em>must</em></span> be placed in the
      <code class="filename">$CONFD_DIR/lib/confd/lib/core/crypto/priv/lib</code>
      directory in the ConfD installation. The Makefiles in the tar
      archive have <code class="code">install</code> targets for
      <code class="filename">libconfd</code> and <code class="filename">crypto.so</code>
      that will do a copy to the appropriate place in the ConfD
      installation if <code class="varname">CONFD_DIR</code> is set to the
      installation directory.
    </p><p>
      As already mentioned, ConfD depends on the OpenSSL
      <code class="filename">libcrypto</code> shared library for its
      cryptography. This shared library can be built to limit the
      cryptographic functions to those available from the OpenSSL
      FIPS 140-2 object module. To use such a variant
      of OpenSSL with ConfD, <code class="filename">crypto.so</code> needs to be
      rebuilt, consult the top level README file included in the
      <code class="filename">confd-&lt;vsn&gt;.libconfd.tar.gz</code> tar archive
      for instructions on how to do this. Note that you also need to
      configure ConfD to use algorithms and crypto suites available from
      the OpenSSL FIPS 140-2 object module. This as algorithms usually
      available in OpenSSL but not included with FIPS are disabled.
      You also need to enable the FIPS mode in ConfD, see
      <code class="sgmltag-element">/confdConfig/fipsMode</code> in
      <a class="xref" href="rn03re17.html" title="confd.conf"><span class="refentrytitle">confd.conf</span>(5)</a>.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.shared_memory_schema"></a>32.15.&nbsp;Using shared memory for schema information</h2></div></div></div><p>
      It is possible to use shared memory to make schema information
      (see <a class="xref" href="rn02re15.html#man.3.confd_types.using_schema_information" title="USING SCHEMA INFORMATION">the section called &#8220;USING SCHEMA INFORMATION&#8221;</a> in
      <a class="xref" href="rn02re15.html" title="confd_types"><span class="refentrytitle">confd_types</span>(3)</a>) available to multiple
      processes on a given host, without requiring each of them to load
      the information directly from ConfD by calling one of the
      schema-loading functions
      (<code class="function">confd_load_schemas()</code> etc, see the <a class="xref" href="rn02re13.html" title="confd_lib_lib"><span class="refentrytitle">confd_lib_lib</span>(3)</a> and <a class="xref" href="rn02re14.html" title="confd_lib_maapi"><span class="refentrytitle">confd_lib_maapi</span>(3)</a> manual pages). This can be a
      very significant performance improvement for system startup, where
      multiple application processes will otherwise load schema
      information more or less simultaneously, and can also reduce RAM
      usage.
    </p><p>
      The mechanism uses a shared memory mapping created by
      <code class="function">mmap(2)</code>, backed by a file. One process needs
      to call first <code class="function">confd_mmap_schemas_setup()</code>, and
      then one of schema-loading functions, to populate the shared
      memory segment. Once this has been done, any process (including
      the one doing the initial load) can call
      <code class="function">confd_mmap_schemas()</code> to map the shared memory
      segment into its address space and make the information available
      to the <code class="filename">libconfd</code> library and for direct access
      by the application. See the <a class="xref" href="rn02re13.html" title="confd_lib_lib"><span class="refentrytitle">confd_lib_lib</span>(3)</a> manual page for the
      specification of these functions.
    </p><p>
      The mechanism can be used in different ways, but assuming that
      persistent storage for the backing file is available, the optimal
      approach is to do the load and file creation step only on first
      system start and when a data model upgrade is done. Then it is
      sufficient to call <code class="function">confd_mmap_schemas()</code> on
      all other occasions. If persistent storage is not available, a
      RAM-based file system such as Linux "tmpfs" can be used for the
      backing file, in which case the load and file creation step needs
      to be done on each boot (and on data model upgrade). It is also
      possible to request that ConfD creates and maintains the backing
      file, see <code class="sgmltag-element">/confdConfig/enableSharedMemorySchema</code> in
      <a class="xref" href="rn03re17.html" title="confd.conf"><span class="refentrytitle">confd.conf</span>(5)</a> and
      <code class="function">maapi_get_schema_file_path()</code> in <a class="xref" href="rn02re14.html" title="confd_lib_maapi"><span class="refentrytitle">confd_lib_maapi</span>(3)</a>.</p><p>
      Since the schema information includes absolute pointers (e.g. the
      <code class="varname">parent</code>, <code class="varname">children</code>, and
      <code class="varname">next</code> pointers in a <span class="type">struct
      confd_cs_node</span>), it is necessary to map the shared memory at
      the same virtual address in all processes. The
      <em class="parameter"><code>addr</code></em> argument to
      <code class="function">confd_mmap_schemas_setup()</code> is passed to
      <code class="function">mmap(2)</code>, and the address returned by
      <code class="function">mmap(2)</code> is used for the mapping. The address
      is also recorded in the shared memory segment to make it available
      for <code class="function">confd_mmap_schemas()</code>. The value of the
      <em class="parameter"><code>size</code></em> argument is also passed in the initial
      <code class="function">mmap(2)</code> invocation, unless it is smaller than
      the first allocation done (e.g. if it is 0). In any case, unless
      the <code class="constant">CONFD_MMAP_SCHEMAS_KEEP_SIZE</code> flag is
      passed to <code class="function">confd_mmap_schemas_setup()</code>, the
      loading will extend the mapped segment as needed, and the final
      size will only be as large as needed for the data, even if a
      larger value was passed as <em class="parameter"><code>size</code></em>.
    </p><p>
      Ideally we would give NULL for the <em class="parameter"><code>addr</code></em>
      argument and an approximate size for <em class="parameter"><code>size</code></em>,
      letting the kernel choose a suitable address and letting the load
      step adjust the final size based on the amount of data loaded.
      Unfortunately this often results in an address that is not
      honored on the subsequent <code class="function">mmap(2)</code> call done
      by <code class="function">confd_mmap_schemas()</code>, which thus fails.
      The possible choices of <em class="parameter"><code>addr</code></em> and/or
      <em class="parameter"><code>size</code></em> to get the desired result are OS- and
      OS-version-dependent, but on Linux it generally works to use an
      <em class="parameter"><code>addr</code></em> argument that is at an offset from the
      top of the heap that is larger than expected heap usage, and give
      <em class="parameter"><code>size</code></em> as 0, as shown in the sample code
      below using a 256 MB offset. (It is not a fatal error if heap
      usage later exceeds this offset, as <code class="function">malloc(3)</code>
      etc will skip over the mapped area, but it may have some
      performance impact.)
    </p><div class="informalexample"><pre class="programlisting">#include &lt;stdio.h&gt;
<span class="hl-directive" style="color: maroon">#include &lt;stdlib.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;stdint.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;unistd.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;assert.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;sys/types.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;sys/socket.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;netinet/in.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;arpa/inet.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;netdb.h&gt;</span>

<span class="hl-directive" style="color: maroon">#include &lt;confd_lib.h&gt;</span>

<span class="hl-directive" style="color: maroon">#define MB (1024 * 1024)</span>
<span class="hl-directive" style="color: maroon">#define SCHEMA_FILE "/etc/schemas"</span>

<span class="hl-directive" style="color: maroon">#define OK(E) do {                                                      \
        int _ret = (E);                                                 \
        if (_ret != CONFD_OK) {                                         \
            confd_fatal(                                                \
                "%s returned %d, confd_errno=%d, confd_lasterr()='%s'\n", \
                #E, _ret, confd_errno, confd_lasterr());                \
        }                                                               \
    } while (0)</span>

<strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> *get_shm_addr(size_t offset)
{
    size_t pagesize;
    <strong class="hl-keyword">char</strong> *addr;

    pagesize = (size_t)sysconf(_SC_PAGESIZE);
    addr = malloc(<span class="hl-number">1</span>);
    free(addr);
    addr += offset;
    <em class="hl-comment" style="color: silver">/* return pagesize-aligned address */</em>
    <strong class="hl-keyword">return</strong> addr - ((uintptr_t)addr % pagesize);
}

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">int</strong> argc, <strong class="hl-keyword">char</strong> **argv)
{
    <strong class="hl-keyword">struct</strong> sockaddr_in addr;
    <strong class="hl-keyword">void</strong> *shm_addr;

    addr.sin_addr.s_addr = inet_addr(<strong class="hl-string"><em style="color:red">"127.0.0.1"</em></strong>);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(CONFD_PORT);

    confd_init(argv[<span class="hl-number">0</span>], stderr, CONFD_TRACE);
    shm_addr = get_shm_addr(<span class="hl-number">256</span> * MB);
    OK(confd_mmap_schemas_setup(shm_addr, <span class="hl-number">0</span>, SCHEMA_FILE <strong class="hl-string"><em style="color:red">".tmp"</em></strong>, <span class="hl-number">0</span>));
    OK(confd_load_schemas((<strong class="hl-keyword">struct</strong> sockaddr *)&amp;addr,
                          <strong class="hl-keyword">sizeof</strong>(<strong class="hl-keyword">struct</strong> sockaddr_in)));
    <strong class="hl-keyword">if</strong> (rename(SCHEMA_FILE <strong class="hl-string"><em style="color:red">".tmp"</em></strong>, SCHEMA_FILE) != <span class="hl-number">0</span>)
        confd_fatal(<strong class="hl-string"><em style="color:red">"Failed to rename\n"</em></strong>);
    <strong class="hl-keyword">return</strong> <span class="hl-number">0</span>;
}</pre></div><p>
      This code uses a temporary file that is renamed after the load is
      complete. This is not necessary, but ensures that the SCHEMA_FILE
      always represents complete schema info if it exists. It can also
      serve as a simple synchronization mechanism to let other processes
      know when they can do their
      <code class="function">confd_mmap_schemas()</code> call.
    </p><p>
      On Solaris (at least Solaris 10), the address passed to
      <code class="function">mmap(2)</code> is effectively ignored, and the
      returned address depends strictly on the size of the mapping. Thus
      there is no point passing anything other than NULL for the
      <em class="parameter"><code>addr</code></em> to
      <code class="function">confd_mmap_schemas_setup()</code>, but instead the
      <em class="parameter"><code>size</code></em> must be big enough for the loaded
      schema info, and the
      <code class="constant">CONFD_MMAP_SCHEMAS_KEEP_SIZE</code> flag must be
      used.
    </p><p>
      In a multi-node system, with application processes connecting to
      ConfD across a network, shared memory can of course not be used
      between the nodes. The most straightforward way to handle this is
      to do the initial load and file creation step on each node. If the
      nodes have the same HW architecture and OS, a possible alternative
      could be to copy the backing store file from one node to the
      others using some file transfer mechanism.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.internal_econfd"></a>32.16.&nbsp;Running application code inside ConfD</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16453"></a>32.16.1.&nbsp;The econfd API</h3></div></div></div><p>
        The Erlang API to ConfD is implemented as an Erlang/OTP
        application called <code class="code">econfd</code>. This application comes
        in two flavours. One is builtin in ConfD in order to support
        applications running in the same Erlang VM as ConfD. The other
        is a separate library which is included in source form in the
        ConfD release, in the <code class="filename">$CONFD_DIR/erlang</code>
        directory. Building <code class="code">econfd</code> as described in the
        <code class="filename">$CONFD_DIR/erlang/econfd/README</code> file will
        compile the Erlang code and generate the documentation.
      </p><p>
        This API can be used by applications written in Erlang in much
        the same way as the C and Java APIs are used, i.e. code running
        in an Erlang VM can use the <code class="code">econfd</code> API functions to
        make socket connections to ConfD for data provider, MAAPI, CDB,
        etc access. However the API is also available internally in
        ConfD, which makes it possible to run Erlang application code
        inside the ConfD daemon, without the overhead imposed by the
        socket communication.
      </p><p>
        There is little or no support for testing and debugging Erlang
        code executing internally in ConfD, since ConfD provides a very
        limited runtime environment for Erlang in order to minimize disk
        and memory footprints. Thus the recommended method is to develop
        Erlang code targeted for this by using <code class="code">econfd</code> in a
        separate Erlang VM, where an interactive Erlang shell and all
        the other development support included in the standard
        Erlang/OTP releases are available. When development and testing
        is completed, the code can be deployed to run internally in
        ConfD without changes.
      </p><p>
        For information about the Erlang programming language and
        development tools, please refer to <a class="link" href="http://www.erlang.org" target="_top">www.erlang.org</a> and the
        available books about Erlang (some are referenced on the web
        site).
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16466"></a>32.16.2.&nbsp;Running inside ConfD</h3></div></div></div><p>
        All application code SHOULD use the prefix "ec_" for module
        names, application names, registered processes (if any), and
        named ets tables (if any), to avoid conflict with existing or
        future names used by ConfD itself.
      </p><p>
        The Erlang code is packaged into applications which are
        automatically started and stopped by ConfD if they are located
        at the proper place. ConfD will search the load path as
        defined by <code class="sgmltag-element">/confdConfig/loadPath</code> for directories
        called <code class="filename">erlang-lib</code>. The structure of such
        a directory is the same as a standard <code class="filename">lib</code>
        directory in Erlang. The directory may contain multiple Erlang
        applications. Each one must have a valid <code class="filename">.app</code>
        file. See the Erlang documentation of <code class="code">application</code>
        and <code class="code">app</code> for more info.
      </p><p>
        The following config settings in the <code class="filename">.app</code>
        file are explicitly treated by ConfD:

        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">applications</span></dt><dd><p>
            A list of applications which needs to be started before
            this application can be started. This info is used to
            compute a valid start order.
          </p></dd><dt><span class="term">included_applications</span></dt><dd><p>
            A list of applications which are started on behalf of this
            application. This info is used to compute a valid start
            order.
          </p></dd><dt><span class="term">env</span></dt><dd><p>
            A property list, containing <code class="code">[{Key,Val}]</code>
            tuples. Besides other keys, used by the application
            itself, a few predefined keys are used by ConfD. The key
            <code class="code">confd_start_phase</code> is used by ConfD to
            determine which start phase the application is to be
            started in. Valid values are <code class="code">early_phase0</code>,
            <code class="code">phase0</code>, <code class="code">phase1</code>,
            <code class="code">phase1_delayed</code> and <code class="code">phase2</code>. Default is
            <code class="code">phase1</code>. If the application is not required in the early
            phases of startup, set <code class="code">confd_start_phase</code> to
            <code class="code">phase2</code> to avoid issues with ConfD services being
            unavailable to the application. The key
            <code class="code">confd_restart_type</code> is used by ConfD to
            determine which impact a restart of the application will
            have. This is the same as the <code class="code">restart_type()</code>
            type in <code class="code">application</code>. Valid values are
            <code class="code">permanent</code>, <code class="code">transient</code> and
            <code class="code">temporary</code>. Default is <code class="code">permanent</code>.
          </p></dd></dl></div><p>
      </p><p>
        When the application is started, one of its processes should
        make initial connections to the ConfD subsystems, register
        callbacks etc. This is typically done in the
        <code class="code">init/1</code> function of a <code class="code">gen_server</code> or
        similar. While the internal connections are made using the
        exact same API functions (e.g.
        <code class="function">econfd_maapi:connect/2</code>) as for an
        application running in an external Erlang VM, any
        <em class="parameter"><code>Address</code></em> and <em class="parameter"><code>Port</code></em>
        arguments are ignored, and instead standard Erlang
        inter-process communication is used. The
        <code class="filename">internal_econfd/embedded_applications/transform</code>
        example in the bundled collection shows a transform written in
        Erlang and executing internally in ConfD.
      </p><p>
        An alternate way (the old way) of running custom code in the
        Erlang VM of ConfD is to load single Erlang modules (as
        opposed to use proper applications). When ConfD starts,
        specifically when <code class="code">phase0</code> is reached, ConfD will
        search the load path as defined by
        <code class="sgmltag-element">/confdConfig/loadPath</code> for compiled Erlang modules,
        i.e. <code class="filename">*.beam</code> files. The modules that are
        found will be loaded, unless the module name conflicts with an
        existing ConfD module. If there is a module name conflict,
        ConfD will terminate with an error message and exit code 21.

        The <a class="link" href="http://www.erlang.org/doc/reference_manual/code_loading.html#on_load" target="_top"><code class="code">-on_load()</code></a>
        directive can be used to spawn a process that makes initial
        connections to the ConfD subsystems, registers callbacks, sets
        up supervision if desired, etc. The
        <code class="filename">internal_econfd/single_modules/transform</code>
        example in the bundled collection shows a transform written in
        Erlang and executing internally in ConfD.
      </p><p>
        The <code class="option">--printlog</code> option to
        <span class="command"><strong>confd</strong></span>, which prints the contents of the ConfD
        errorLog, is normally only useful for Cisco support and
        developers, but it may also be relevant for debugging problems
        with application code running inside ConfD. The errorLog
        collects the events sent to the OTP error_logger, e.g. crash
        reports as well as info generated by calls to functions in the
        error_logger(3) module. Another possibility for primitive
        debugging is to run <span class="command"><strong>confd</strong></span> with the
        <code class="option">--foreground</code> option, where calls to
        <code class="function">io:format/2</code> etc will print to standard
        output. Printouts may also be directed to the developer log
        by using <code class="function">econfd:log/3</code>.
      </p><p>
        While Erlang application code running in an external Erlang VM
        can use basically any version of Erlang/OTP, this is not the
        case for code running inside ConfD, since the Erlang VM is
        evolving and provides limited backward/forward compatibility.
        To avoid incompatibility issues when loading the
        <code class="code">beam</code> files, the Erlang compiler <code class="code">erlc</code>
        in same version the ConfD distribution should be used.
      </p><p>
        ConfD provides the VM, <code class="code">erlc</code> and the
        <code class="code">kernel</code>, <code class="code">stdlib</code>, and
        <code class="code">crypto</code> OTP applications.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        Obviously application code running internally in the ConfD
        daemon can have an impact on the execution of the standard ConfD
        code. Thus it is critically important that the application code
        is thoroughly tested and verified before being deployed for
        production in a system using ConfD.
      </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16539"></a>32.16.3.&nbsp;User-defined types</h3></div></div></div><p>
        We can implement user-defined types with Erlang code in a manner
        similar to what is described for C in <a class="xref" href="rn02re15.html#man.3.confd_types.userdefined_types" title="USER-DEFINED TYPES">the section called &#8220;USER-DEFINED TYPES&#8221;</a> in <a class="xref" href="rn02re15.html" title="confd_types"><span class="refentrytitle">confd_types</span>(3)</a>. In the econfd API, we
        populate a <code class="code">#confd_type_cbs{}</code> record and register it
        using <code class="function">econfd_schema:register_type_cbs/1</code>.
        For an application running inside ConfD, this registration will
        have the same effect as using a shared object in the C API,
        i.e. the callback functions will be used internally by ConfD for
        doing string &lt;-&gt; value translation and syntax validation.
      </p><p>
        Callbacks for user-defined types may in general be required to
        be registered very early in the ConfD startup, in particular
        default values specified in the YANG data model will be
        translated from string form to internal representation when
        the corresponding <code class="filename">.fxs</code> file is loaded. A
        really early start of the application is achieved by using the
        <code class="code">early_phase0</code> as <code class="code">confd_start_phase</code> in
        the application <code class="code">.app</code> file. An application
        started in this early phase should not have e.g. registration
        of normal data provider callbacks, since ConfD is not prepared
        to handle such registrations at this early point in the
        startup. The
        <code class="filename">internal_econfd/embedded_applications/user_type</code>
        example shows how the callbacks can be implemented in Erlang.
      </p><p>
        An alternate way (the old way) of defining ConfD
        user-defined-types in Erlang is to load a single module (as
        opposed to use a proper application). By giving a module
        implementing such callbacks a name starting with
        "<code class="code">ec_user_type</code>" (i.e. file name
        <code class="filename">ec_user_type*.beam</code>), we can tell ConfD
        that it should be loaded early enough for default value
        translation. The
        <code class="filename">internal_econfd/single_modules/user_type</code>
        example shows how the callbacks can be implemented in
        Erlang. It uses this naming convention to be able to handle
        the translation of a default value specified in the data
        model.
      </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.advanced.external_logging"></a>32.17.&nbsp;External Logging</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16558"></a>32.17.1.&nbsp;Introduction</h3></div></div></div><p>
        As a development feature ConfD supports sending log data
        as-is to an external command for reading on standard input. As
        this is a development feature there are a few limitations such
        as the data sent to the external command is not guaranteed to be
        processed before the external application is shut down.
      </p><p>
        The <code class="filename">misc/extern_logging</code> example in the
        bundled collection shows a log filtering command written in
        Python processing raw NETCONF trace data and discarding all
        other types of log data.
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16563"></a>32.17.2.&nbsp;Enabling external log processing</h3></div></div></div><p>
        General configuration of the external log processing is done in
        <code class="filename">confd.conf</code>.
      </p><p>
        To enable external log processing set
        <code class="code">/confdConfig/logs/external</code> to <code class="code">true</code>
        and <code class="code">/confdConfig/logs/command</code> to the full path of
        the command that will receive the log data. The same
        executable will be used for all log types. External
        configuration example:
        </p><div class="informalexample"><pre class="programlisting">&lt;external&gt;
  &lt;enabled&gt;true&lt;/enabled&gt;
  &lt;command&gt;./path/to/log_filter&lt;/command&gt;
&lt;/external&gt;</pre></div><p>
      </p><p>
        To support debugging of the external log command behavior a
        separate log file is used. This debugging log is configured
        under <code class="code">/confdConfig/logs/extLog</code>. The example below
        shows configuration for <code class="filename">./logs/external.log</code>
        with the highest log level set:

        </p><div class="informalexample"><pre class="programlisting">&lt;extLog&gt;
  &lt;enabled&gt;true&lt;/enabled&gt;
  &lt;filename&gt;./logs/external.log&lt;/filename&gt;
  &lt;level&gt;7&lt;/level&gt;
&lt;/extLog&gt;</pre></div><p>
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="d5e16578"></a>32.17.3.&nbsp;Processing logs using an external command</h3></div></div></div><p>
        After enabling external log processing, ConfD will start one
        instance of the external command for each configured log
        destination. Processing of the log data is done by reading
        from standard input and processing it as required.
      </p><p>
        The command line arguments provide information about the log
        that is being processed and in what format the data is sent.
      </p><p>
        The example below shows how the configured command
        <code class="code">./log_processor</code> would be executed for
        <span class="emphasis"><em>NETCONF trace</em></span> data configured to log in raw
        mode:

        </p><div class="informalexample"><pre class="programlisting">./log_processor 1 log "NETCONF Trace" netconf-trace raw</pre></div><p>

        Command line argument position and meaning:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <span class="emphasis"><em>version</em></span>. Protocol version, always set
              to <span class="emphasis"><em>1</em></span>. Added for forwards compatibility.
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>action</em></span>. Action being performed,
              always set to <span class="emphasis"><em>log</em></span>. Added for forwards
              compatibility.
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>name</em></span>. Name of the log being
              processed.
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>log-type</em></span>. Type of log data being
              processed. For all but NETCONF trace and SNMP gateway
              logs this is set to <span class="emphasis"><em>system</em></span>.
              NETCONF trace is set to
              <span class="emphasis"><em>netconf-trace</em></span> and SNMP gateway is
              set to <span class="emphasis"><em>SNMPGW</em></span>
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>log-mode</em></span>. Format of log data being
              sent. For all but NETCONF logs this will be
              <span class="emphasis"><em>raw</em></span>. NETCONF trace logs can be
              pretty printed and then format will be
              <span class="emphasis"><em>pretty</em></span>.
            </p></li></ol></div><p>
      </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch31.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="rn01.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;31.&nbsp;Progress Trace&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;ConfD man-pages, Volume 1</td></tr></table></div></body></html>