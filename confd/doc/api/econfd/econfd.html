<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module econfd</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module econfd</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>An Erlang interface equivalent to the confd_lib_dp C-API   
(documented in confd_lib_dp(3)).
<p>Copyright Â© 2006 Tail-F Systems AB</p>

<p><b>Version:</b> {$Id$}</p>

<h2><a name="description">Description</a></h2><p>An Erlang interface equivalent to the confd_lib_dp C-API   
(documented in confd_lib_dp(3)).</p>
  
   This module is used to connect to ConfD and provide callback
   functions so that ConfD can populate its northbound agent
   interfaces with external data.  Thus the library consists of a
   number of API functions whose purpose is to install different
   callback functions at different points in the XML tree which is
   the representation of the device configuration. Read more about
   callpoints in the ConfD User Guide.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-cb_action">cb_action()</a></h3>
<p><tt>cb_action() = <a href="#type-cb_action_act">cb_action_act()</a> | <a href="#type-cb_action_cmd">cb_action_cmd()</a></tt></p>
<p>  It is the callback for #confd_action_cb.action</p>

<h3 class="typedecl"><a name="type-cb_action_act">cb_action_act()</a></h3>
<p><tt>cb_action_act() = fun((U::#confd_user_info{}, Name::<a href="#type-qtag">qtag()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, [Param::<a href="#type-tagval">tagval()</a>]) -&gt; ok | {ok, [Result::<a href="#type-tagval">tagval()</a>]} | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  It is the callback for #confd_action_cb.action when invoked as an
  action request.</p>

<h3 class="typedecl"><a name="type-cb_action_cmd">cb_action_cmd()</a></h3>
<p><tt>cb_action_cmd() = fun((U::#confd_user_info{}, Name::binary(), Path::binary(), [Arg::binary()]) -&gt; ok | {ok, [Result::binary()]} | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  It is the callback for #confd_action_cb.action when invoked as a
  CLI command callback.</p>

<h3 class="typedecl"><a name="type-cb_authentication">cb_authentication()</a></h3>
<p><tt>cb_authentication() = fun((#confd_authentication_ctx{}) -&gt; ok | error | {error, binary()})</tt></p>
<p>  The callback for #confd_authentication_cb.auth</p>

<h3 class="typedecl"><a name="type-cb_candidate_commit">cb_candidate_commit()</a></h3>
<p><tt>cb_candidate_commit() = fun((#confd_db_ctx{}, Timeout::integer()) -&gt; ok | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  The callback for #confd_db_cbs.candidate_commit</p>

<h3 class="typedecl"><a name="type-cb_completion_action">cb_completion_action()</a></h3>
<p><tt>cb_completion_action() = fun((U::#confd_user_info{}, CliStyle::integer(), Token::binary(), CompletionChar::integer(), IKP::<a href="#type-ikeypath">ikeypath()</a>, CmdPath::binary(), Id::binary(), TP::term(), Extra::term()) -&gt; [string() | {info, string()} | {desc, string()} | default])</tt></p>
<p>  It is the callback for #confd_action_cb.action when invoked as a
  CLI command completion.</p>

<h3 class="typedecl"><a name="type-cb_create">cb_create()</a></h3>
<p><tt>cb_create() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  It is the callback for #confd_data_cbs.create. Only used
  when we use external database config data, e.g. not for statistics.</p>

<h3 class="typedecl"><a name="type-cb_ctx">cb_ctx()</a></h3>
<p><tt>cb_ctx() = fun((<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  The callback for #confd_trans_validate_cbs.init and
  #confd_trans_cbs.init as well as
  several other callbacks in #confd_trans_cbs{}</p>

<h3 class="typedecl"><a name="type-cb_db">cb_db()</a></h3>
<p><tt>cb_db() = fun((#confd_db_ctx{}, DbName::integer()) -&gt; ok | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  The callback for #confd_db_cbs.lock, #confd_db_cbs.unlock, and
  #confd_db_cbs.delete_config</p>

<h3 class="typedecl"><a name="type-cb_exists_optional">cb_exists_optional()</a></h3>
<p><tt>cb_exists_optional() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; {ok, <a href="#type-cb_exists_optional_reply">cb_exists_optional_reply()</a>} | {ok, <a href="#type-cb_exists_optional_reply">cb_exists_optional_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.exists_optional.
  The exists_optional callback must be present
  if our YANG model has presence containers or leafs of type empty.</p>

<h3 class="typedecl"><a name="type-cb_exists_optional_reply">cb_exists_optional_reply()</a></h3>
<p><tt>cb_exists_optional_reply() = boolean()</tt></p>


<h3 class="typedecl"><a name="type-cb_find_next">cb_find_next()</a></h3>
<p><tt>cb_find_next() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, FindNextType::integer(), PrevKey::<a href="#type-key">key()</a>) -&gt; {ok, <a href="#type-cb_find_next_reply">cb_find_next_reply()</a>} | {ok, <a href="#type-cb_find_next_reply">cb_find_next_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.find_next.</p>

<h3 class="typedecl"><a name="type-cb_find_next_object">cb_find_next_object()</a></h3>
<p><tt>cb_find_next_object() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, FindNextType::integer(), PrevKey::<a href="#type-key">key()</a>) -&gt; {ok, <a href="#type-cb_find_next_object_reply">cb_find_next_object_reply()</a>} | {ok, <a href="#type-cb_find_next_object_reply">cb_find_next_object_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {ok, <a href="#type-objects">objects()</a>, TimeoutMillisecs::integer()} | {ok, <a href="#type-objects">objects()</a>, TimeoutMillisecs::integer(), <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  Optional callback which combines the functionality of
  find_next() and get_object(), and adds the possibility
  to return multiple objects.
  It is the callback for #confd_data_cbs.find_next_object.
  For a detailed description of the two forms of the value list,
  please refer to the "Value Array" and "Tag Value Array" specifications,
  respectively, in the XML STRUCTURES section of the confd_types(3)
  manual page.</p>

<h3 class="typedecl"><a name="type-cb_find_next_object_reply">cb_find_next_object_reply()</a></h3>
<p><tt>cb_find_next_object_reply() = <a href="#type-vals_next">vals_next()</a> | <a href="#type-tag_val_object_next">tag_val_object_next()</a> | {false, undefined}</tt></p>


<h3 class="typedecl"><a name="type-cb_find_next_reply">cb_find_next_reply()</a></h3>
<p><tt>cb_find_next_reply() = {Key::<a href="#type-key">key()</a>, Next::term()} | {false, undefined}</tt></p>


<h3 class="typedecl"><a name="type-cb_get_attrs">cb_get_attrs()</a></h3>
<p><tt>cb_get_attrs() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, [Attr::integer()]) -&gt; {ok, <a href="#type-cb_get_attrs_reply">cb_get_attrs_reply()</a>} | {ok, <a href="#type-cb_get_attrs_reply">cb_get_attrs_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.get_attrs.</p>

<h3 class="typedecl"><a name="type-cb_get_attrs_reply">cb_get_attrs_reply()</a></h3>
<p><tt>cb_get_attrs_reply() = [{Attr::integer(), V::<a href="#type-value">value()</a>}] | not_found</tt></p>


<h3 class="typedecl"><a name="type-cb_get_case">cb_get_case()</a></h3>
<p><tt>cb_get_case() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, ChoicePath::[<a href="#type-qtag">qtag()</a>]) -&gt; {ok, <a href="#type-cb_get_case_reply">cb_get_case_reply()</a>} | {ok, <a href="#type-cb_get_case_reply">cb_get_case_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.get_case. Only used when we
  use 'choice' in the data model.
  Normally ChoicePath is just a single element with the name of the
  choice, but if we have nested choices without intermediate data nodes,
  it will be similar to an ikeypath, i.e. a reversed list of choice and
  case names giving the path through the nested choices.</p>

<h3 class="typedecl"><a name="type-cb_get_case_reply">cb_get_case_reply()</a></h3>
<p><tt>cb_get_case_reply() = <a href="#type-qtag">qtag()</a> | not_found</tt></p>


<h3 class="typedecl"><a name="type-cb_get_elem">cb_get_elem()</a></h3>
<p><tt>cb_get_elem() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; {ok, <a href="#type-cb_get_elem_reply">cb_get_elem_reply()</a>} | {ok, <a href="#type-cb_get_elem_reply">cb_get_elem_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.get_elem.</p>

<h3 class="typedecl"><a name="type-cb_get_elem_reply">cb_get_elem_reply()</a></h3>
<p><tt>cb_get_elem_reply() = <a href="#type-value">value()</a> | not_found</tt></p>


<h3 class="typedecl"><a name="type-cb_get_log_times">cb_get_log_times()</a></h3>
<p><tt>cb_get_log_times() = fun((#confd_notification_ctx{}) -&gt; {ok, {Created::<a href="#type-datetime">datetime()</a>, Aged::<a href="#type-datetime">datetime()</a> | not_found}} | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  The callback for #confd_notification_stream_cbs.get_log_times</p>

<h3 class="typedecl"><a name="type-cb_get_next">cb_get_next()</a></h3>
<p><tt>cb_get_next() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, Prev::term()) -&gt; {ok, <a href="#type-cb_get_next_reply">cb_get_next_reply()</a>} | {ok, <a href="#type-cb_get_next_reply">cb_get_next_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.get_next.  Prev is
  the integer -1 on the first call.</p>

<h3 class="typedecl"><a name="type-cb_get_next_object">cb_get_next_object()</a></h3>
<p><tt>cb_get_next_object() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, Prev::term()) -&gt; {ok, <a href="#type-cb_get_next_object_reply">cb_get_next_object_reply()</a>} | {ok, <a href="#type-cb_get_next_object_reply">cb_get_next_object_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {ok, <a href="#type-objects">objects()</a>, TimeoutMillisecs::integer()} | {ok, <a href="#type-objects">objects()</a>, TimeoutMillisecs::integer(), <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  Optional callback which combines the functionality of
  get_next() and get_object(), and adds the possibility
  to return multiple objects.
  It is the callback for #confd_data_cbs.get_next_object.
  For a detailed description of the two forms of the value list,
  please refer to the "Value Array" and "Tag Value Array" specifications,
  respectively, in the XML STRUCTURES section of the confd_types(3)
  manual page.</p>

<h3 class="typedecl"><a name="type-cb_get_next_object_reply">cb_get_next_object_reply()</a></h3>
<p><tt>cb_get_next_object_reply() = <a href="#type-vals_next">vals_next()</a> | <a href="#type-tag_val_object_next">tag_val_object_next()</a> | {false, undefined}</tt></p>


<h3 class="typedecl"><a name="type-cb_get_next_reply">cb_get_next_reply()</a></h3>
<p><tt>cb_get_next_reply() = {Key::<a href="#type-key">key()</a>, Next::term()} | {false, undefined}</tt></p>


<h3 class="typedecl"><a name="type-cb_get_object">cb_get_object()</a></h3>
<p><tt>cb_get_object() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; {ok, <a href="#type-cb_get_object_reply">cb_get_object_reply()</a>} | {ok, <a href="#type-cb_get_object_reply">cb_get_object_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  Optional callback which is used to return an entire object.
  It is the callback for #confd_data_cbs.get_object.
  For a detailed description of the two forms of the value list,
  please refer to the "Value Array" and "Tag Value Array" specifications,
  respectively, in the XML STRUCTURES section of the confd_types(3)
  manual page.</p>

<h3 class="typedecl"><a name="type-cb_get_object_reply">cb_get_object_reply()</a></h3>
<p><tt>cb_get_object_reply() = <a href="#type-vals">vals()</a> | <a href="#type-tag_val_object">tag_val_object()</a> | not_found</tt></p>


<h3 class="typedecl"><a name="type-cb_lock_partial">cb_lock_partial()</a></h3>
<p><tt>cb_lock_partial() = fun((#confd_db_ctx{}, DbName::integer(), LockId::integer(), [<a href="#type-ikeypath">ikeypath()</a>]) -&gt; ok | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  The callback for #confd_db_cbs.lock_partial</p>

<h3 class="typedecl"><a name="type-cb_move_after">cb_move_after()</a></h3>
<p><tt>cb_move_after() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, PrevKeys::{<a href="#type-value">value()</a>}) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.move_after. PrevKeys == {}
  means that the list entry should become the first one.</p>

<h3 class="typedecl"><a name="type-cb_num_instances">cb_num_instances()</a></h3>
<p><tt>cb_num_instances() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; {ok, <a href="#type-cb_num_instances_reply">cb_num_instances_reply()</a>} | {ok, <a href="#type-cb_num_instances_reply">cb_num_instances_reply()</a>, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  Optional callback, if it doesn't exist it will be emulated
  by consecutive calls to get_next().
  It is the callback for #confd_data_cbs.num_instances.</p>

<h3 class="typedecl"><a name="type-cb_num_instances_reply">cb_num_instances_reply()</a></h3>
<p><tt>cb_num_instances_reply() = integer()</tt></p>


<h3 class="typedecl"><a name="type-cb_ok">cb_ok()</a></h3>
<p><tt>cb_ok() = fun((<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>) -&gt; ok | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  The callback for #confd_trans_cbs.finish and
  #confd_trans_validate_cbs.stop</p>

<h3 class="typedecl"><a name="type-cb_ok_db">cb_ok_db()</a></h3>
<p><tt>cb_ok_db() = fun((#confd_db_ctx{}) -&gt; ok | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  The callback for #confd_db_cbs.candidate_confirming_commit
  and several other callbacks in #confd_db_cbs{}</p>

<h3 class="typedecl"><a name="type-cb_remove">cb_remove()</a></h3>
<p><tt>cb_remove() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  It is the callback for #confd_data_cbs.remove. Only used
  when we use external database config data, e.g. not for statistics.</p>

<h3 class="typedecl"><a name="type-cb_replay">cb_replay()</a></h3>
<p><tt>cb_replay() = fun((#confd_notification_ctx{}, Start::<a href="#type-datetime">datetime()</a>, Stop::<a href="#type-datetime">datetime()</a> | undefined) -&gt; ok | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  The callback for #confd_notification_stream_cbs.replay</p>

<h3 class="typedecl"><a name="type-cb_set_attr">cb_set_attr()</a></h3>
<p><tt>cb_set_attr() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, Attr::integer(), <a href="#type-cb_set_attr_value">cb_set_attr_value()</a>) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.set_attr. Value == undefined
  means that the attribute should be deleted.</p>

<h3 class="typedecl"><a name="type-cb_set_attr_value">cb_set_attr_value()</a></h3>
<p><tt>cb_set_attr_value() = <a href="#type-value">value()</a> | undefined</tt></p>


<h3 class="typedecl"><a name="type-cb_set_case">cb_set_case()</a></h3>
<p><tt>cb_set_case() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, ChoicePath::[<a href="#type-qtag">qtag()</a>], Case::<a href="#type-qtag">qtag()</a> | '$none') -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.set_case. Only used when we
  use 'choice' in the data model. Case == '$none'
  means that no case is chosen (i.e. all have been deleted).
  Normally ChoicePath is just a single element with the name of the
  choice, but if we have nested choices without intermediate data nodes,
  it will be similar to an ikeypath, i.e. a reversed list of choice and
  case names giving the path through the nested choices.</p>

<h3 class="typedecl"><a name="type-cb_set_elem">cb_set_elem()</a></h3>
<p><tt>cb_set_elem() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, Value::<a href="#type-value">value()</a>) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  It is the callback for #confd_data_cbs.set_elem. Only used
  when we use external database config data, e.g. not for statistics.</p>

<h3 class="typedecl"><a name="type-cb_str_to_val">cb_str_to_val()</a></h3>
<p><tt>cb_str_to_val() = fun((TypeCtx::term(), String::string()) -&gt; {ok, Value::<a href="#type-value">value()</a>} | error | {error, Reason::binary()} | none())</tt></p>
<p>  The callback for #confd_type_cbs.str_to_val. The TypeCtx argument is
  currently unused (passed as 'undefined'). The function may fail - this
  is equivalent to returning 'error'.</p>

<h3 class="typedecl"><a name="type-cb_trans_lock">cb_trans_lock()</a></h3>
<p><tt>cb_trans_lock() = fun((<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | confd_already_locked)</tt></p>
<p>  The callback for #confd_trans_cbs.trans_lock. The confd_already_locked
  return value is equivalent to {error, #confd_error{ code = in_use }}.</p>

<h3 class="typedecl"><a name="type-cb_unlock_partial">cb_unlock_partial()</a></h3>
<p><tt>cb_unlock_partial() = fun((#confd_db_ctx{}, DbName::integer(), LockId::integer()) -&gt; ok | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  The callback for #confd_db_cbs.unlock_partial</p>

<h3 class="typedecl"><a name="type-cb_val_to_str">cb_val_to_str()</a></h3>
<p><tt>cb_val_to_str() = fun((TypeCtx::term(), Value::<a href="#type-value">value()</a>) -&gt; {ok, String::string()} | error | {error, Reason::binary()} | none())</tt></p>
<p>  The callback for #confd_type_cbs.val_to_str. The TypeCtx argument is
  currently unused (passed as 'undefined'). The function may fail - this
  is equivalent to returning 'error'.</p>

<h3 class="typedecl"><a name="type-cb_validate">cb_validate()</a></h3>
<p><tt>cb_validate() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>, Newval::<a href="#type-value">value()</a>) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {validation_warn, Reason::binary()} | {error, <a href="#type-error_reason">error_reason()</a>})</tt></p>
<p>  It is the callback for #confd_valpoint_cb.validate.</p>

<h3 class="typedecl"><a name="type-cb_validate_value">cb_validate_value()</a></h3>
<p><tt>cb_validate_value() = fun((TypeCtx::term(), Value::<a href="#type-value">value()</a>) -&gt; ok | error | {error, Reason::binary()} | none())</tt></p>
<p>  The callback for #confd_type_cbs.validate. The TypeCtx argument is
  currently unused (passed as 'undefined'). The function may fail - this
  is equivalent to returning 'error'.</p>

<h3 class="typedecl"><a name="type-cb_write">cb_write()</a></h3>
<p><tt>cb_write() = fun((<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | confd_in_use)</tt></p>
<p>  The callback for #confd_trans_cbs.write_start and
  #confd_trans_cbs.prepare. The confd_in_use return value is equivalent to
  {error, #confd_error{ code = in_use }}.</p>

<h3 class="typedecl"><a name="type-cb_write_all">cb_write_all()</a></h3>
<p><tt>cb_write_all() = fun((T::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, KP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; ok | {ok, <a href="#type-confd_trans_ctx">confd_trans_ctx()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | delayed_response)</tt></p>
<p>  This is the callback for #confd_data_cbs.write_all. The KP argument
  is currently always [], since the callback does not pertain to any
  particular data node.</p>

<h3 class="typedecl"><a name="type-cmp_op">cmp_op()</a></h3>
<p><tt>cmp_op() = 0 | 1 | 2 | 3 | 4 | 5 | 6</tt></p>


<h3 class="typedecl"><a name="type-confd_trans_ctx">confd_trans_ctx()</a></h3>
<p><tt>confd_trans_ctx() = #confd_trans_ctx{}</tt></p>


<h3 class="typedecl"><a name="type-connect_result">connect_result()</a></h3>
<p><tt>connect_result() = {ok, <a href="#type-socket">socket()</a>} | {error, <a href="#type-error_reason">error_reason()</a>} | {error, atom()}</tt></p>
<p>  This is the return type of connect() function.</p>

<h3 class="typedecl"><a name="type-datetime">datetime()</a></h3>
<p><tt>datetime() = {C_DATETIME::integer(), <a href="#type-datetime_date_and_time">datetime_date_and_time()</a>}</tt></p>
<p>  The value representation for yang:date-and-time, also used in the
  API functions for notification streams.</p>

<h3 class="typedecl"><a name="type-datetime_date_and_time">datetime_date_and_time()</a></h3>
<p><tt>datetime_date_and_time() = {Year::integer(), Month::integer(), Day::integer(), Hour::integer(), Minute::integer(), Second::integer(), MicroSecond::integer(), TZ::integer(), TZMinutes::integer()}</tt></p>


<h3 class="typedecl"><a name="type-error_reason">error_reason()</a></h3>
<p><tt>error_reason() = binary() | #confd_error{} | tuple()</tt></p>
<p>  The callback functions may return errors either as a plain string
  or via a #confd_error{} record - see econfd.hrl and the section EXTENDED
  ERROR REPORTING in confd_lib_lib(3) (tuple() is only for internal
  ConfD/NCS use). {error, String} is equivalent to
  {error, #confd_error{ code = application, str = String }}.</p>

<h3 class="typedecl"><a name="type-exec_op">exec_op()</a></h3>
<p><tt>exec_op() = 7 | 8 | 9 | 10</tt></p>


<h3 class="typedecl"><a name="type-ikeypath">ikeypath()</a></h3>
<p><tt>ikeypath() = [<a href="#type-qtag">qtag()</a> | <a href="#type-key">key()</a>]</tt></p>
<p>  An ikeypath() is a list describing a path down into the data tree.
  The Ikeypaths are used to denote specific objects in the XML instance
  document.  The list is in backwards order, thus the head of the list
  is the leaf element.  All the data callbacks defined in
  #confd_data_cbs{} receive ikeypath() lists as an argument.  The last
  (top) element of the list is a pair <code>[NS|XmlTag]</code> where NS is
  the atom defining the XML namespace of the XmlTag and
  XmlTag is an XmlTag::atom() denoting the toplevel XML element.
  Elements in the list that have a different namespace than their parent
  are also qualified through such a pair with the element's namespace,
  but all other elements are represented by their unqualified tag() atom.
  Thus an ikeypath() uniquely addresses an instance of an element in
  the configuration XML tree.  List entries are
  identified by an element in the ikeypath() list expressed as {Key}
  or, when we are using CDB, as [Integer]. During an individual CDB
  session all the elements are implictly numbered, thus we can through
  a call to econfd_cdb:num_instances/2 retrieve how many entries (N)
  for a given list that we have, and then retrieve those entries
  (0 - (N-1)) inserting [I] as the key.</p>

<h3 class="typedecl"><a name="type-ip">ip()</a></h3>
<p><tt>ip() = <a href="#type-ipv4">ipv4()</a> | <a href="#type-ipv6">ipv6()</a></tt></p>
<p>  4-tuples for IP v4 addresses and 8-tuples for IP v6 addresses.</p>

<h3 class="typedecl"><a name="type-ipv4">ipv4()</a></h3>
<p><tt>ipv4() = {0..255, 0..255, 0..255, 0..255}</tt></p>


<h3 class="typedecl"><a name="type-ipv6">ipv6()</a></h3>
<p><tt>ipv6() = {0..65535, 0..65535, 0..65535, 0..65535, 0..65535, 0..65535, 0..65535, 0..65535}</tt></p>


<h3 class="typedecl"><a name="type-key">key()</a></h3>
<p><tt>key() = {<a href="#type-value">value()</a>} | [Index::integer()]</tt></p>
<p>  Keys are parts of ikeypath(). In the YANG data model we define how many
  keys a list node has. If we have 1 key, the key is an arity-1
  tuple, 2 keys - an arity-2 tuple and so forth.
  The [Index] notation is only valid for keys in ikeypaths when we use CDB.</p>

<h3 class="typedecl"><a name="type-list_filter_op">list_filter_op()</a></h3>
<p><tt>list_filter_op() = <a href="#type-cmp_op">cmp_op()</a> | <a href="#type-exec_op">exec_op()</a></tt></p>


<h3 class="typedecl"><a name="type-list_filter_type">list_filter_type()</a></h3>
<p><tt>list_filter_type() = 0 | 1 | 2 | 3 | 4 | 5 | 6</tt></p>


<h3 class="typedecl"><a name="type-namespace">namespace()</a></h3>
<p><tt>namespace() = atom()</tt></p>


<h3 class="typedecl"><a name="type-objects">objects()</a></h3>
<p><tt>objects() = [<a href="#type-vals_next">vals_next()</a> | <a href="#type-tag_val_object_next">tag_val_object_next()</a> | false]</tt></p>


<h3 class="typedecl"><a name="type-qtag">qtag()</a></h3>
<p><tt>qtag() = <a href="#type-tag">tag()</a> | <a href="#type-tag_cons">tag_cons</a>(<a href="#type-namespace">namespace()</a>, <a href="#type-tag">tag()</a>)</tt></p>
<p>  A "qualified tag" is either a single tag or a pair of a namespace and a
  tag.  An example could be 'interface' or
  ['http://example.com/ns/interfaces/2.1' | interface]</p>

<h3 class="typedecl"><a name="type-socket">socket()</a></h3>
<p><tt>socket() = port() | <a href="int_ipc.html#type-sock">int_ipc:sock()</a></tt></p>
<p>  When running econfd internally the socket is a tuple.</p>

<h3 class="typedecl"><a name="type-tag">tag()</a></h3>
<p><tt>tag() = atom()</tt></p>


<h3 class="typedecl"><a name="type-tag_cons">tag_cons()</a></h3>
<p><tt>tag_cons(T1, T2) = nonempty_improper_list(T1, T2)</tt></p>


<h3 class="typedecl"><a name="type-tag_val_object">tag_val_object()</a></h3>
<p><tt>tag_val_object() = {exml, [TV::<a href="#type-tagval">tagval()</a>]}</tt></p>


<h3 class="typedecl"><a name="type-tag_val_object_next">tag_val_object_next()</a></h3>
<p><tt>tag_val_object_next() = {<a href="#type-tag_val_object">tag_val_object()</a>, Next::term()}</tt></p>


<h3 class="typedecl"><a name="type-tagpath">tagpath()</a></h3>
<p><tt>tagpath() = [<a href="#type-qtag">qtag()</a>]</tt></p>
<p>  A tagpath() is a list describing a path down into the schema tree.
  I.e. as opposed to an ikeypath(), it has no instance information.
  Additionally the last (top) element is not <code>[NS|XmlTag]</code> as in
  ikeypath(), but only <code>XmlTag</code> - i.e. it needs to be combined with
  a namespace to uniquely identify a schema node. The other elements
  in the path are qualified - or not - exactly as for ikeypath().</p>

<h3 class="typedecl"><a name="type-tagval">tagval()</a></h3>
<p><tt>tagval() = {<a href="#type-qtag">qtag()</a>, <a href="#type-value">value()</a> | start | {start, Index::integer()} | stop | leaf | delete}</tt></p>
<p>  This is used to represent XML elements together with their values,
  typically in a list representing an XML subtree as in the arguments
  and result of the 'action' callback. Typeless elements have the
  special "values":<ul>
  <li><code>start</code> - opening container or list element.</li>
  <li><code>{start, Index :: integer()}</code> - opening list element with CDB Index
  instead of key value(s) - only valid for CDB access.</li>
  <li><code>stop</code> - closing container or list element.</li>
  <li><code>leaf</code> - leaf with type "empty".</li>
  <li><code>delete</code> - delete list entry.</li></ul>
  The qtag() tuple element may have the namespace()-less form (i.e. tag()) for
  XML elements in the "current" namespace. For a detailed description of how to
  represent XML as a list of tagval() elements, please refer to the "Tagged
  Value Array" specification in the XML STRUCTURES section of the
  confd_types(3) manual page.</p>

<h3 class="typedecl"><a name="type-transport_error">transport_error()</a></h3>
<p><tt>transport_error() = timeout | closed</tt></p>


<h3 class="typedecl"><a name="type-type">type()</a></h3>
<p><tt>type() = term()</tt></p>
<p>  Identifies a type definition in the schema.</p>

<h3 class="typedecl"><a name="type-vals">vals()</a></h3>
<p><tt>vals() = [V::<a href="#type-value">value()</a>]</tt></p>


<h3 class="typedecl"><a name="type-vals_next">vals_next()</a></h3>
<p><tt>vals_next() = {<a href="#type-vals">vals()</a>, Next::term()}</tt></p>


<h3 class="typedecl"><a name="type-value">value()</a></h3>
<p><tt>value() = binary() | tuple() | float() | boolean() | integer() | <a href="#type-qtag">qtag()</a> | {Tag::integer(), Value::term()} | [<a href="#type-value">value()</a>] | not_found | default</tt></p>
<p><p>  This type is central for this library. Values are returned from the CDB  
functions, they are used to read and write in the MAAPI module and they  
are also used as keys in ikeypath().</p>
 
  We have the following value representation for the data model types
 <ul>
  <li> string - Always represented as a single binary. </li>
  <li> int32  - This is represented as a single integer. </li>
  <li> int8   - {?C_INT8, Val} </li>
  <li> int16  - {?C_INT16, Val} </li>
  <li> int64  - {?C_INT64, Val} </li>
  <li> uint8  - {?C_UINT8, Val} </li>
  <li> uint16 - {?C_UINT16, Val} </li>
  <li> uint32 - {?C_UINT32, Val} </li>
  <li> uint64 - {?C_UINT64, Val} </li>
  <li> inet:ipv4-address - 4-tuple </li>
  <li> inet:ipv4-address-no-zone - 4-tuple </li>
  <li> inet:ipv6-address - 8-tuple </li>
  <li> inet:ipv6-address-no-zone - 8-tuple </li>
  <li> boolean - The atoms 'true' or 'false' </li>
  <li> xs:float() and xs:double() - Erlang floats </li>
  <li> leaf-list - An erlang list of values. </li>
  <li> binary, yang:hex-string, tailf:hex-list (etc) -
       {?C_BINARY, binary()} </li>
  <li> yang:date-and-time - {?C_DATETIME, datetime_date_and_time()} </li>
  <li> xs:duration - {?C_DURATION, {Y,M,D,H,M,S,Mcr}} </li>
  <li> instance-identifier - {?C_OBJECTREF, econfd:ikeypath()} </li>
  <li> yang:object-identifier - {?C_OID, Int32Binary}, where Int32Binary is a
       binary with OID compontents as 32-bit integers in the default
       big endianness. </li>
  <li> yang:dotted-quad - {?C_DQUAD, binary()} </li>
  <li> yang:hex-string  - {?C_HEXSTR, binary()} </li>
  <li> inet:ipv4-prefix - {?C_IPV4PREFIX, {{A,B,C,D}, PrefixLen}} </li>
  <li> inet:ipv6-prefix - {?C_IPV6PREFIX, {{A,B,C,D,E,F,G,H}, PrefixLen}} </li>
  <li> tailf:ipv4-address-and-prefix-length -
       {?C_IPV4_AND_PLEN, {{A,B,C,D}, PrefixLen}} </li>
  <li> tailf:ipv6-address-and-prefix-length -
       {?C_IPV6_AND_PLEN, {{A,B,C,D,E,F,G,H}, PrefixLen}} </li>
  <li> decimal64 - {?C_DECIMAL64, {Int64, FractionDigits}} </li>
  <li> identityref - {?C_IDENTITYREF, {NsHash, IdentityHash}} </li>
  <li> bits - {?C_BIT32, Bits::integer()}, {?C_BIT64, Bits::integer()}, or
       {?C_BITBIG, Bits:binary()}
       depending on the highest bit position assigned </li>
  <li> enumeration - {?C_ENUM_VALUE, IntVal}, where IntVal is the integer
       value for a given "enum" statement according to the YANG specification.
       When we have compiled a YANG module into a .fxs file, we can use the
       --emit-hrl option to confdc(1) to create a .hrl file with macro
       definitions for the enum values. </li>
 </ul>
 
  <p>There is also a "pseudo type" that indicates a non-existing value,  
which is represented as the atom 'not_found'.  
Finally there is a "pseudo type" to indicate that a leaf with a default  
value defined in the data model does not have a value set - this is  
represented as the atom 'default'.</p>
 
  For all of the abovementioned (non-"pseudo") types we have the corresponding
  macro in econfd.hrl. We strongly suggest that the ?CONFD_xxx macros are used
  whenever we either want to construct a value or match towards a value:
  Thus we write code as:
  <pre>
   case econfd_cdb:get_elem(...) of
       {ok, ?CONFD_INT64(42)} -&gt;
           foo;
 
  or
   econfd_cdb:set_elem(... ?CONFD_INT64(777), ...)
 
  or
   {ok, ?CONFD_INT64(I)} = econfd_cdb:get_elem(...)
 
 </pre></p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#action_set_timeout-2">action_set_timeout/2</a></td><td>Extend (or shorten) the timeout for the current action callback
  invocation.</td></tr>
<tr><td valign="top"><a href="#bitbig_bit_is_set-2">bitbig_bit_is_set/2</a></td><td>Test a bit in a C_BITBIG binary.</td></tr>
<tr><td valign="top"><a href="#bitbig_clr_bit-2">bitbig_clr_bit/2</a></td><td>Clear a bit in a C_BITBIG binary.</td></tr>
<tr><td valign="top"><a href="#bitbig_set_bit-2">bitbig_set_bit/2</a></td><td>Set a bit in a C_BITBIG binary.</td></tr>
<tr><td valign="top"><a href="#controlling_process-2">controlling_process/2</a></td><td>Assigns a new controlling process Pid to Socket.</td></tr>
<tr><td valign="top"><a href="#data_get_list_filter-1">data_get_list_filter/1</a></td><td>Return list filter for the current operation if any.</td></tr>
<tr><td valign="top"><a href="#data_reply_error-2">data_reply_error/2</a></td><td>Reply an error for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_found-1">data_reply_found/1</a></td><td>Reply 'found' for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_next_key-3">data_reply_next_key/3</a></td><td>Reply with next key for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_next_object_tag_value_array-3">data_reply_next_object_tag_value_array/3</a></td><td>Reply with tagged values and next key for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_next_object_value_array-3">data_reply_next_object_value_array/3</a></td><td>Reply with values and next key for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_next_object_value_arrays-3">data_reply_next_object_value_arrays/3</a></td><td>Reply with multiple objects, each with values and next key, plus
  cache timeout, for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_not_found-1">data_reply_not_found/1</a></td><td>Reply 'not found' for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_ok-1">data_reply_ok/1</a></td><td>Reply 'ok' for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_tag_value_array-2">data_reply_tag_value_array/2</a></td><td>Reply a list of tagged values for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_value-2">data_reply_value/2</a></td><td>Reply a value for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_reply_value_array-2">data_reply_value_array/2</a></td><td>Reply a list of values for delayed_response.</td></tr>
<tr><td valign="top"><a href="#data_set_filtered-2">data_set_filtered/2</a></td><td>Set filtered flag on transaction context in the first callback
  call of a list traversal.</td></tr>
<tr><td valign="top"><a href="#data_set_timeout-2">data_set_timeout/2</a></td><td>Extend (or shorten) the timeout for the current callback invocation.</td></tr>
<tr><td valign="top"><a href="#decrypt-1">decrypt/1</a></td><td>Decrypts a value of type tailf:des3-cbc-encrypted-string
  or tailf:aes-cfb-128-encrypted-string.</td></tr>
<tr><td valign="top"><a href="#init_daemon-6">init_daemon/6</a></td><td>Starts and links to a gen_server which connects to ConfD.</td></tr>
<tr><td valign="top"><a href="#log-2">log/2</a></td><td>Logs Fmt to devel.log if running internal, otherwise to
  standard out.</td></tr>
<tr><td valign="top"><a href="#log-3">log/3</a></td><td>Logs Fmt with Args to devel.log if running internal,
  otherwise to standard out.</td></tr>
<tr><td valign="top"><a href="#log-4">log/4</a></td><td>Logs Fmt with Args to devel.log if running internal,
  otherwise to IoDevice.</td></tr>
<tr><td valign="top"><a href="#notification_replay_complete-1">notification_replay_complete/1</a></td><td>Call this function when replay is done.</td></tr>
<tr><td valign="top"><a href="#notification_replay_failed-2">notification_replay_failed/2</a></td><td>Call this function when replay has failed for some reason.</td></tr>
<tr><td valign="top"><a href="#notification_send-3">notification_send/3</a></td><td>Send a notification defined at the top level of a YANG module.</td></tr>
<tr><td valign="top"><a href="#notification_send-4">notification_send/4</a></td><td>Send a notification defined as a child of a container or list
  in a YANG 1.1 module.</td></tr>
<tr><td valign="top"><a href="#pp_kpath-1">pp_kpath/1</a></td><td>Pretty print an ikeypath.</td></tr>
<tr><td valign="top"><a href="#pp_value-1">pp_value/1</a></td><td>Pretty print a value.</td></tr>
<tr><td valign="top"><a href="#register_action_cb-2">register_action_cb/2</a></td><td>Register action callback on an actionpoint.</td></tr>
<tr><td valign="top"><a href="#register_authentication_cb-2">register_authentication_cb/2</a></td><td>Register authentication callback.</td></tr>
<tr><td valign="top"><a href="#register_data_cb-2">register_data_cb/2</a></td><td>Register the data callbacks.</td></tr>
<tr><td valign="top"><a href="#register_data_cb-3">register_data_cb/3</a></td><td>Register the data callbacks.</td></tr>
<tr><td valign="top"><a href="#register_db_cbs-2">register_db_cbs/2</a></td><td>Register extern db callbacks.</td></tr>
<tr><td valign="top"><a href="#register_done-1">register_done/1</a></td><td>This function must be called when all callback registrations are done.</td></tr>
<tr><td valign="top"><a href="#register_notification_stream-2">register_notification_stream/2</a></td><td>Register notif callbacks on an streamname.</td></tr>
<tr><td valign="top"><a href="#register_range_data_cb-5">register_range_data_cb/5</a></td><td>Register data callbacks for a range of keys.</td></tr>
<tr><td valign="top"><a href="#register_trans_cb-2">register_trans_cb/2</a></td><td>Register transaction phase callbacks.</td></tr>
<tr><td valign="top"><a href="#register_trans_validate_cb-2">register_trans_validate_cb/2</a></td><td>Register validation transaction callback.</td></tr>
<tr><td valign="top"><a href="#register_valpoint_cb-2">register_valpoint_cb/2</a></td><td>Register validation callback on a valpoint.</td></tr>
<tr><td valign="top"><a href="#set_daemon_d_opaque-2">set_daemon_d_opaque/2</a></td><td>Set the d_opaque field in the daemon which is typically
  used by the callbacks.</td></tr>
<tr><td valign="top"><a href="#set_daemon_flags-2">set_daemon_flags/2</a></td><td>Change the flag settings for a daemon.</td></tr>
<tr><td valign="top"><a href="#set_debug-3">set_debug/3</a></td><td>Change the DebugLevel and/or Estream for a running daemon.</td></tr>
<tr><td valign="top"><a href="#start-0">start/0</a></td><td>Starts the econfd application.</td></tr>
<tr><td valign="top"><a href="#stop_daemon-1">stop_daemon/1</a></td><td>Silently stop a daemon.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="action_set_timeout-2">action_set_timeout/2</a></h3>
<div class="spec">
<p><tt>action_set_timeout(Uinfo::#confd_user_info{}, Seconds::integer()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Extend (or shorten) the timeout for the current action callback
  invocation. The timeout is given in seconds from the point in time when
  the function is called.</p>

<h3 class="function"><a name="bitbig_bit_is_set-2">bitbig_bit_is_set/2</a></h3>
<div class="spec">
<p><tt>bitbig_bit_is_set(Binary::binary(), Position::integer()) -&gt; boolean()</tt><br></p>
</div><p>Test a bit in a C_BITBIG binary.</p>

<h3 class="function"><a name="bitbig_clr_bit-2">bitbig_clr_bit/2</a></h3>
<div class="spec">
<p><tt>bitbig_clr_bit(Binary::binary(), Position::integer()) -&gt; binary()</tt><br></p>
</div><p>Clear a bit in a C_BITBIG binary.</p>

<h3 class="function"><a name="bitbig_set_bit-2">bitbig_set_bit/2</a></h3>
<div class="spec">
<p><tt>bitbig_set_bit(Binary::binary(), Position::integer()) -&gt; binary()</tt><br></p>
</div><p>Set a bit in a C_BITBIG binary.</p>

<h3 class="function"><a name="controlling_process-2">controlling_process/2</a></h3>
<div class="spec">
<p><tt>controlling_process(Socket::term(), Pid::pid()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Assigns a new controlling process Pid to Socket</p>

<h3 class="function"><a name="data_get_list_filter-1">data_get_list_filter/1</a></h3>
<div class="spec">
<p><tt>data_get_list_filter(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>) -&gt; undefined | #confd_list_filter{type = <a href="econfd.html#type-list_filter_type">econfd:list_filter_type()</a>, expr1 = undefined | #confd_list_filter{type = <a href="econfd.html#type-list_filter_type">econfd:list_filter_type()</a>, expr1 = undefined | #confd_list_filter{}, expr2 = undefined | #confd_list_filter{}, op = undefined | <a href="econfd.html#type-list_filter_op">econfd:list_filter_op()</a>, node = undefined | <a href="econfd.html#type-ikeypath">econfd:ikeypath()</a>, val = undefined | <a href="econfd.html#type-value">econfd:value()</a>}, expr2 = undefined | #confd_list_filter{type = <a href="econfd.html#type-list_filter_type">econfd:list_filter_type()</a>, expr1 = undefined | #confd_list_filter{}, expr2 = undefined | #confd_list_filter{}, op = undefined | <a href="econfd.html#type-list_filter_op">econfd:list_filter_op()</a>, node = undefined | <a href="econfd.html#type-ikeypath">econfd:ikeypath()</a>, val = undefined | <a href="econfd.html#type-value">econfd:value()</a>}, op = undefined | <a href="econfd.html#type-list_filter_op">econfd:list_filter_op()</a>, node = undefined | <a href="econfd.html#type-ikeypath">econfd:ikeypath()</a>, val = undefined | <a href="econfd.html#type-value">econfd:value()</a>}</tt><br></p>
</div><p>Return list filter for the current operation if any.</p>

<h3 class="function"><a name="data_reply_error-2">data_reply_error/2</a></h3>
<div class="spec">
<p><tt>data_reply_error(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, Error::<a href="#type-error_reason">error_reason()</a>) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply an error for delayed_response.
  Like data_reply_value() - only used in combination with delayed_response.</p>

<h3 class="function"><a name="data_reply_found-1">data_reply_found/1</a></h3>
<div class="spec">
<p><tt>data_reply_found(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply 'found' for delayed_response.
  Like data_reply_value() - only used in combination with delayed_response.</p>

<h3 class="function"><a name="data_reply_next_key-3">data_reply_next_key/3</a></h3>
<div class="spec">
<p><tt>data_reply_next_key(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, Key::<a href="#type-key">key()</a> | false, Next::term()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply with next key for delayed_response.
  Like data_reply_value() - only used in combination with delayed_response.</p>

<h3 class="function"><a name="data_reply_next_object_tag_value_array-3">data_reply_next_object_tag_value_array/3</a></h3>
<div class="spec">
<p><tt>data_reply_next_object_tag_value_array(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, Values::[TV::<a href="#type-tagval">tagval()</a>], Next::term()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply with tagged values and next key for delayed_response.
  Like data_reply_value() - only used in combination with delayed_response,
  and get_next_object() callback.</p>

<h3 class="function"><a name="data_reply_next_object_value_array-3">data_reply_next_object_value_array/3</a></h3>
<div class="spec">
<p><tt>data_reply_next_object_value_array(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, Values::<a href="#type-vals">vals()</a> | <a href="#type-tag_val_object">tag_val_object()</a> | false, Next::term()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply with values and next key for delayed_response.
  Like data_reply_value() - only used in combination with delayed_response,
  and get_next_object() callback.</p>

<h3 class="function"><a name="data_reply_next_object_value_arrays-3">data_reply_next_object_value_arrays/3</a></h3>
<div class="spec">
<p><tt>data_reply_next_object_value_arrays(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, Objects::<a href="#type-objects">objects()</a>, TimeoutMillisecs::integer()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply with multiple objects, each with values and next key, plus
  cache timeout, for delayed_response.
  Like data_reply_value() - only used in combination with delayed_response,
  and get_next_object() callback.</p>

<h3 class="function"><a name="data_reply_not_found-1">data_reply_not_found/1</a></h3>
<div class="spec">
<p><tt>data_reply_not_found(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply 'not found' for delayed_response.
  Like data_reply_value() - only used in combination with delayed_response.</p>

<h3 class="function"><a name="data_reply_ok-1">data_reply_ok/1</a></h3>
<div class="spec">
<p><tt>data_reply_ok(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply 'ok' for delayed_response.
  This function can be used explicitly by the erlang application
  if a data callback returns the atom delayed_response. In that
  case it is the responsibility of the application to later
  invoke one of the data_reply_xxx() functions. If delayed_response is
  not used, none of the explicit data replying functions need to be used.</p>

<h3 class="function"><a name="data_reply_tag_value_array-2">data_reply_tag_value_array/2</a></h3>
<div class="spec">
<p><tt>data_reply_tag_value_array(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, TagVals::[<a href="#type-tagval">tagval()</a>]) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply a list of tagged values for delayed_response.
  Like data_reply_value() - only used in combination with delayed_response,
  and get_object() callback.</p>

<h3 class="function"><a name="data_reply_value-2">data_reply_value/2</a></h3>
<div class="spec">
<p><tt>data_reply_value(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, V::<a href="#type-value">value()</a>) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply a value for delayed_response.
  This function can be used explicitly by the erlang application
  if a data callback returns the atom delayed_response. In that
  case it is the responsibility of the application to later
  invoke one of the data_reply_xxx() functions. If delayed_response is
  not used, none of the explicit data replying functions need to be used.</p>

<h3 class="function"><a name="data_reply_value_array-2">data_reply_value_array/2</a></h3>
<div class="spec">
<p><tt>data_reply_value_array(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, Values::<a href="#type-vals">vals()</a> | <a href="#type-tag_val_object">tag_val_object()</a> | false) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Reply a list of values for delayed_response.
  Like data_reply_value() - only used in combination with delayed_response,
  and get_object() callback.</p>

<h3 class="function"><a name="data_set_filtered-2">data_set_filtered/2</a></h3>
<div class="spec">
<p><tt>data_set_filtered(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, IsFiltered::boolean()) -&gt; <a href="#type-confd_trans_ctx">confd_trans_ctx()</a></tt><br></p>
</div><p>Set filtered flag on transaction context in the first callback
  call of a list traversal. This signals that all list entries
  returned by the data provider for this list traversal match the
  filter.</p>

<h3 class="function"><a name="data_set_timeout-2">data_set_timeout/2</a></h3>
<div class="spec">
<p><tt>data_set_timeout(Tctx::<a href="#type-confd_trans_ctx">confd_trans_ctx()</a>, Seconds::integer()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Extend (or shorten) the timeout for the current callback invocation.
  The timeout is given in seconds from the point in time when the function
  is called.</p>

<h3 class="function"><a name="decrypt-1">decrypt/1</a></h3>
<div class="spec">
<p><tt>decrypt(X1::binary()) -&gt; {ok, binary()} | {error, {Ecode::integer(), Reason::binary()}}</tt><br></p>
</div><p>Decrypts a value of type tailf:des3-cbc-encrypted-string
  or tailf:aes-cfb-128-encrypted-string. Requires that
  econfd_maapi:install_crypto_keys/1 has been called in the node.</p>

<h3 class="function"><a name="init_daemon-6">init_daemon/6</a></h3>
<div class="spec">
<p><tt>init_daemon(Name::atom(), DebugLevel::integer(), Estream::<a href="io.html#type-device">io:device()</a>, Dopaque::term(), Ip::<a href="#type-ip">ip()</a>, Port::integer()) -&gt; {ok, Pid::pid()} | {error, Reason::term()}</tt><br></p>
</div><p><p>Starts and links to a gen_server which connects to ConfD.  
This gen_server holds two sockets to ConfD, one so called control  
socket and one worker socket (See confd_lib_dp(3) for an explanation  
of those sockets.)</p>
 
  <p>To avoid blocking control socket callback requests due to  
long-running worker socket callbacks, the control socket callbacks  
are run in the gen_server, while the worker socket callbacks are run  
in a separate process that is spawned by the gen_server. This means  
that applications must not share e.g. MAAPI sockets between  
transactions, since this could result in simultaneous use of a socket  
by the gen_server and the spawned process.</p>
 
  <p>The gen_server is used to install sets of callback Funs.  The  
gen_server state is a #confd_daemon_ctx{}. This structure is passed  
to all the callback functions.</p>
 
  <p>The daemon context includes a d_opaque element holding the Dopaque  
term - this can be used by the application to pass application  
specific data into the callback functions.</p>
 
  <p>The Name::atom() parameter is used in various debug printouts and  
is also used to uniquely identify the daemon.</p>
 
  <p>The  DebugLevel parameter is used to control the  
debug level. The following levels are available:</p>
 
  <ul><li>?CONFD_SILENT
         No debug printouts whatsoever are produced by the library.
 </li><li>
 ?CONFD_DEBUG
        Various printouts will occur for various error conditions.
 </li><li>
 ?CONFD_TRACE
        The execution of callback functions will be traced.
 </li></ul>
        The Estream parameter is used by all printouts from the
        library.</p>

<h3 class="function"><a name="log-2">log/2</a></h3>
<div class="spec">
<p><tt>log(Level::integer(), Fmt::string()) -&gt; ok</tt><br></p>
</div><p>Logs Fmt to devel.log if running internal, otherwise to
  standard out. Level can be one of ?CONFD_LEVEL_ERROR |
  ?CONFD_LEVEL_INFO | ?CONFD_LEVEL_TRACE</p>

<h3 class="function"><a name="log-3">log/3</a></h3>
<div class="spec">
<p><tt>log(Level::integer(), Fmt::string(), Args::list()) -&gt; ok</tt><br></p>
</div><p>Logs Fmt with Args to devel.log if running internal,
  otherwise to standard out. Level can be one of
  ?CONFD_LEVEL_ERROR | ?CONFD_LEVEL_INFO | ?CONFD_LEVEL_TRACE</p>

<h3 class="function"><a name="log-4">log/4</a></h3>
<div class="spec">
<p><tt>log(IoDevice::<a href="io.html#type-device">io:device()</a>, Level::integer(), Fmt::string(), Args::list()) -&gt; ok</tt><br></p>
</div><p>Logs Fmt with Args to devel.log if running internal,
  otherwise to IoDevice. Level can be one of
  ?CONFD_LEVEL_ERROR | ?CONFD_LEVEL_INFO | ?CONFD_LEVEL_TRACE</p>

<h3 class="function"><a name="notification_replay_complete-1">notification_replay_complete/1</a></h3>
<div class="spec">
<p><tt>notification_replay_complete(Nctx::#confd_notification_ctx{}) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Call this function when replay is done</p>

<h3 class="function"><a name="notification_replay_failed-2">notification_replay_failed/2</a></h3>
<div class="spec">
<p><tt>notification_replay_failed(Nctx::#confd_notification_ctx{}, ErrorString::binary()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Call this function when replay has failed for some reason</p>

<h3 class="function"><a name="notification_send-3">notification_send/3</a></h3>
<div class="spec">
<p><tt>notification_send(Nctx::#confd_notification_ctx{}, DateTime::<a href="#type-datetime">datetime()</a>, TagVals::[<a href="#type-tagval">tagval()</a>]) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Send a notification defined at the top level of a YANG module.</p>

<h3 class="function"><a name="notification_send-4">notification_send/4</a></h3>
<div class="spec">
<p><tt>notification_send(Nctx::#confd_notification_ctx{}, DateTime::<a href="#type-datetime">datetime()</a>, TagVals::[<a href="#type-tagval">tagval()</a>], IKP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Send a notification defined as a child of a container or list
  in a YANG 1.1 module. IKP is the fully instantiated path for the
  parent of the notification in the data tree.</p>

<h3 class="function"><a name="pp_kpath-1">pp_kpath/1</a></h3>
<div class="spec">
<p><tt>pp_kpath(IKP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; iolist()</tt><br></p>
</div><p>Pretty print an ikeypath.</p>

<h3 class="function"><a name="pp_value-1">pp_value/1</a></h3>
<div class="spec">
<p><tt>pp_value(V::<a href="#type-value">value()</a>) -&gt; iolist()</tt><br></p>
</div><p>Pretty print a value.</p>

<h3 class="function"><a name="register_action_cb-2">register_action_cb/2</a></h3>
<div class="spec">
<p><tt>register_action_cb(Daemon::pid(), ActionCbs::#confd_action_cb{}) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Register action callback on an actionpoint</p>

<h3 class="function"><a name="register_authentication_cb-2">register_authentication_cb/2</a></h3>
<div class="spec">
<p><tt>register_authentication_cb(Daemon::pid(), AuthenticationCb::#confd_authentication_cb{}) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Register authentication callback.
  Note, this can not be used to *perform* the authentication.</p>

<h3 class="function"><a name="register_data_cb-2">register_data_cb/2</a></h3>
<div class="spec">
<p><tt>register_data_cb(Daemon::pid(), DbCbs::#confd_data_cbs{callpoint = any(), exists_optional = any(), get_elem = any(), get_next = any(), set_elem = any(), create = any(), remove = any(), find_next = any(), num_instances = any(), get_object = any(), get_next_object = any(), find_next_object = any(), get_case = undefined | <a href="econfd.html#type-cb_get_case">econfd:cb_get_case()</a>, set_case = undefined | <a href="econfd.html#type-cb_set_case">econfd:cb_set_case()</a>, get_attrs = any(), set_attr = any(), move_after = any(), write_all = any(), index = any()}) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Register the data callbacks.</p>

<h3 class="function"><a name="register_data_cb-3">register_data_cb/3</a></h3>
<div class="spec">
<p><tt>register_data_cb(Daemon::pid(), DbCbs::#confd_data_cbs{callpoint = any(), exists_optional = any(), get_elem = any(), get_next = any(), set_elem = any(), create = any(), remove = any(), find_next = any(), num_instances = any(), get_object = any(), get_next_object = any(), find_next_object = any(), get_case = undefined | <a href="econfd.html#type-cb_get_case">econfd:cb_get_case()</a>, set_case = undefined | <a href="econfd.html#type-cb_set_case">econfd:cb_set_case()</a>, get_attrs = any(), set_attr = any(), move_after = any(), write_all = any(), index = any()}, Flags::non_neg_integer()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Register the data callbacks.</p>

<h3 class="function"><a name="register_db_cbs-2">register_db_cbs/2</a></h3>
<div class="spec">
<p><tt>register_db_cbs(Daemon::pid(), DbCbs::#confd_db_cbs{}) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Register extern db callbacks.</p>

<h3 class="function"><a name="register_done-1">register_done/1</a></h3>
<div class="spec">
<p><tt>register_done(Daemon::pid()) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>This function must be called when all callback registrations are done.</p>

<h3 class="function"><a name="register_notification_stream-2">register_notification_stream/2</a></h3>
<div class="spec">
<p><tt>register_notification_stream(Daemon::pid(), NotifCbs::#confd_notification_stream_cbs{}) -&gt; {ok, #confd_notification_ctx{}} | {error, Reason::term()}</tt><br></p>
</div><p>Register notif callbacks on an streamname</p>

<h3 class="function"><a name="register_range_data_cb-5">register_range_data_cb/5</a></h3>
<div class="spec">
<p><tt>register_range_data_cb(Daemon::pid(), DataCbs::#confd_data_cbs{callpoint = any(), exists_optional = any(), get_elem = any(), get_next = any(), set_elem = any(), create = any(), remove = any(), find_next = any(), num_instances = any(), get_object = any(), get_next_object = any(), find_next_object = any(), get_case = undefined | <a href="econfd.html#type-cb_get_case">econfd:cb_get_case()</a>, set_case = undefined | <a href="econfd.html#type-cb_set_case">econfd:cb_set_case()</a>, get_attrs = any(), set_attr = any(), move_after = any(), write_all = any(), index = any()}, Lower::[Lower::<a href="#type-value">value()</a>], Higher::[Higher::<a href="#type-value">value()</a>], IKP::<a href="#type-ikeypath">ikeypath()</a>) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Register data callbacks for a range of keys.</p>

<h3 class="function"><a name="register_trans_cb-2">register_trans_cb/2</a></h3>
<div class="spec">
<p><tt>register_trans_cb(Daemon::pid(), TransCbs::#confd_trans_cbs{}) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Register transaction phase callbacks.
  See confd_lib_dp(3) for a thorough description of the transaction phases.
  The record #confd_trans_cbs{} contains callbacks for all of the
  phases for a transaction. If we use this external data api only for
  statistics data only the init() and the finish() callbacks should be
  used.  The init() callback must return 'ok', {error, String}, or {ok, Tctx}
  where Tctx is the same #confd_trans_ctx that was supplied to the
  init callback but possibly with the opaque field filled in. This field
  is meant to be used by the user to manage user data.</p>

<h3 class="function"><a name="register_trans_validate_cb-2">register_trans_validate_cb/2</a></h3>
<div class="spec">
<p><tt>register_trans_validate_cb(Daemon::pid(), ValidateCbs::#confd_trans_validate_cbs{}) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Register validation transaction callback.
  This function maps an init and a finish function for validations.
  See seme function in confd_lib_dp(3)
  The init() callback must return 'ok', {error, String}, or {ok, Tctx}
  where Tctx is the same #confd_trans_ctx that was supplied to the
  init callback but possibly with the opaque field filled in.</p>

<h3 class="function"><a name="register_valpoint_cb-2">register_valpoint_cb/2</a></h3>
<div class="spec">
<p><tt>register_valpoint_cb(Daemon::pid(), ValpointCbs::#confd_valpoint_cb{}) -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Register validation callback on a valpoint</p>

<h3 class="function"><a name="set_daemon_d_opaque-2">set_daemon_d_opaque/2</a></h3>
<div class="spec">
<p><tt>set_daemon_d_opaque(Daemon::pid(), Dopaque::term()) -&gt; ok</tt><br></p>
</div><p>Set the d_opaque field in the daemon which is typically
  used by the callbacks</p>

<h3 class="function"><a name="set_daemon_flags-2">set_daemon_flags/2</a></h3>
<div class="spec">
<p><tt>set_daemon_flags(Daemon, Flags) -&gt; ok</tt>
<ul class="definitions"><li><tt>Daemon = pid()</tt></li><li><tt>Flags = non_neg_integer()</tt></li></ul></p>
</div><p>Change the flag settings for a daemon. See ?CONFD_DAEMON_FLAG_XXX
  in econfd.hrl for the available flags. This function should be called
  immediately after creating the daemon context with init_daemon/6.</p>

<h3 class="function"><a name="set_debug-3">set_debug/3</a></h3>
<div class="spec">
<p><tt>set_debug(Daemon::pid(), DebugLevel::integer(), Estream::<a href="io.html#type-device">io:device()</a>) -&gt; ok</tt><br></p>
</div><p>Change the DebugLevel and/or Estream for a running daemon</p>

<h3 class="function"><a name="start-0">start/0</a></h3>
<div class="spec">
<p><tt>start() -&gt; ok | {error, Reason::term()}</tt><br></p>
</div><p>Starts the econfd application.</p>

<h3 class="function"><a name="stop_daemon-1">stop_daemon/1</a></h3>
<div class="spec">
<p><tt>stop_daemon(Daemon::pid()) -&gt; ok</tt><br></p>
</div><p>Silently stop a daemon</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
