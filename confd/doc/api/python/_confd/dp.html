<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>_confd.dp API documentation</title>
<meta name="description" content="Low level callback module for connecting data providers to ConfD …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>
#pubhub-container .pubhub-doc-container article#content,
#pubhub-container .pubhub-doc-container nav#sidebar {
width: inherit;
height: inherit;
}
</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>_confd.dp</code></h1>
</header>
<section id="section-intro">
<p>Low level callback module for connecting data providers to ConfD.</p>
<p>This module is used to connect to the ConfD Data Provider
API. The purpose of this API is to provide callback hooks so that
user-written data providers can provide data stored externally to ConfD.
ConfD needs this information in order to drive its northbound agents.</p>
<p>The module is also used to populate items in the data model which are not
data or configuration items, such as statistics items from the device.</p>
<p>The module consists of a number of API functions whose purpose is to
install different callback functions at different points in the data model
tree which is the representation of the device configuration. Read more
about callpoints in tailf_yang_extensions(5). Read more about how to use
the module in the User Guide chapters on Operational data and External
data.</p>
<p>This documentation should be read together with the confd_lib_dp(3) man page.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="_confd.dp.aaa_reload"><code class="name flex">
<span>def <span class="ident">aaa_reload</span></span>(<span>tctx)</span>
</code></dt>
<dd>
<div class="desc"><p>When the ConfD AAA tree is populated by an external data provider (see the
AAA chapter in the User Guide), this function can be used by the data
provider to notify ConfD when there is a change to the AAA data.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
</ul></div>
</dd>
<dt id="_confd.dp.access_reply_result"><code class="name flex">
<span>def <span class="ident">access_reply_result</span></span>(<span>actx, result)</span>
</code></dt>
<dd>
<div class="desc"><p>The callbacks must call this function to report the result of the access
check to ConfD, and should normally return CONFD_OK. If any other value is
returned, it will cause the access check to be rejected.</p>
<p>Keyword arguments:</p>
<ul>
<li>actx &ndash; the authorization context</li>
<li>result &ndash; the result (ACCESS_RESULT_xxx)</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_delayed_reply_error"><code class="name flex">
<span>def <span class="ident">action_delayed_reply_error</span></span>(<span>uinfo, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>If we use the CONFD_DELAYED_RESPONSE as a return value from the action
callback, we must later asynchronously reply. This function is used to
reply with error.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>errstr &ndash; an error string</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_delayed_reply_ok"><code class="name flex">
<span>def <span class="ident">action_delayed_reply_ok</span></span>(<span>uinfo)</span>
</code></dt>
<dd>
<div class="desc"><p>If we use the CONFD_DELAYED_RESPONSE as a return value from the action
callback, we must later asynchronously reply. This function is used to
reply with success.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_reply_command"><code class="name flex">
<span>def <span class="ident">action_reply_command</span></span>(<span>uinfo, values)</span>
</code></dt>
<dd>
<div class="desc"><p>If a CLI callback command should return data, it must invoke this function
in response to the cb_command() callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>values &ndash; a list of strings or None</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_reply_completion"><code class="name flex">
<span>def <span class="ident">action_reply_completion</span></span>(<span>uinfo, values)</span>
</code></dt>
<dd>
<div class="desc"><p>This function must normally be called in response to the cb_completion()
callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>values &ndash; a list of 3-tuples or None (see below)</li>
</ul>
<p>The values argument must be None or a list of 3-tuples where each tuple is
built up like:</p>
<pre><code>(type::int, value::string, extra::string)
</code></pre>
<p>The third item of the tuple (extra) may be set to None.</p></div>
</dd>
<dt id="_confd.dp.action_reply_range_enum"><code class="name flex">
<span>def <span class="ident">action_reply_range_enum</span></span>(<span>uinfo, values, keysize)</span>
</code></dt>
<dd>
<div class="desc"><p>This function must be called in response to the cb_completion() callback
when it is invoked via a tailf:cli-custom-range-enumerator statement in the
data model.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>values &ndash; a list of keys as strings or None</li>
<li>keysize &ndash; number of keys for the list in the data model</li>
</ul>
<p>The values argument is a flat list of keys. If the list in the data model
specifies multiple keys this list is still flat. The keysize argument
tells us how many keys to use for each list element. So the size of values
should be a multiple of keysize.</p></div>
</dd>
<dt id="_confd.dp.action_reply_rewrite"><code class="name flex">
<span>def <span class="ident">action_reply_rewrite</span></span>(<span>uinfo, values, unhides)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be called instead of action_reply_command() as a
response to a show path rewrite callback invocation.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>values &ndash; a list of strings or None</li>
<li>unhides &ndash; a list of strings or None</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_reply_rewrite2"><code class="name flex">
<span>def <span class="ident">action_reply_rewrite2</span></span>(<span>uinfo, values, unhides, selects)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be called instead of action_reply_command() as a
response to a show path rewrite callback invocation.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>values &ndash; a list of strings or None</li>
<li>unhides &ndash; a list of strings or None</li>
<li>selects &ndash; a list of strings or None</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_reply_values"><code class="name flex">
<span>def <span class="ident">action_reply_values</span></span>(<span>uinfo, values)</span>
</code></dt>
<dd>
<div class="desc"><p>If the action definition specifies that the action should return data, it
must invoke this function in response to the cb_action() callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>values &ndash; a list of _lib.TagValue instances or None</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_set_fd"><code class="name flex">
<span>def <span class="ident">action_set_fd</span></span>(<span>uinfo, sock)</span>
</code></dt>
<dd>
<div class="desc"><p>Associate a worker socket with the action. This function must be called in
the action cb_init() callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>sock &ndash; a previously connected worker socket</li>
</ul>
<p>A typical implementation of an action cb_init() callback looks like:</p>
<pre><code>class ActionCallbacks(object):
    def __init__(self, workersock):
        self.workersock = workersock

    def cb_init(self, uinfo):
        dp.action_set_fd(uinfo, self.workersock)
</code></pre></div>
</dd>
<dt id="_confd.dp.action_set_timeout"><code class="name flex">
<span>def <span class="ident">action_set_timeout</span></span>(<span>uinfo, timeout_secs)</span>
</code></dt>
<dd>
<div class="desc"><p>Some action callbacks may require a significantly longer execution time
than others, and this time may not even be possible to determine statically
(e.g. a file download). In such cases the /confdConfig/capi/queryTimeout
setting in confd.conf may be insufficient, and this function can be used to
extend (or shorten) the timeout for the current callback invocation. The
timeout is given in seconds from the point in time when the function is
called.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>timeout_secs &ndash; timeout value</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_seterr"><code class="name flex">
<span>def <span class="ident">action_seterr</span></span>(<span>uinfo, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>If action callback encounters fatal problems that can not be expressed via
the reply function, it may call this function with an appropriate message
and return CONFD_ERR instead of CONFD_OK.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_seterr_extended"><code class="name flex">
<span>def <span class="ident">action_seterr_extended</span></span>(<span>uninfo, code, apptag_ns, apptag_tag, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be used to provide more structured error information
from an action callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>code &ndash; an error code</li>
<li>apptag_ns &ndash; namespace - should be set to 0</li>
<li>apptag_tag &ndash; either 0 or the hash value for a data model node</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.action_seterr_extended_info"><code class="name flex">
<span>def <span class="ident">action_seterr_extended_info</span></span>(<span>uinfo, code, apptag_ns, apptag_tag, error_info, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be used to provide structured error information in the
same way as action_seterr_extended(), and additionally provide contents for
the NETCONF <error-info> element.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>code &ndash; an error code</li>
<li>apptag_ns &ndash; namespace - should be set to 0</li>
<li>apptag_tag &ndash; either 0 or the hash value for a data model node</li>
<li>error_info &ndash; a list of _lib.TagValue instances</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.auth_seterr"><code class="name flex">
<span>def <span class="ident">auth_seterr</span></span>(<span>actx, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the application to set an error string.</p>
<p>This function can be used to provide a text message when the callback
returns CONFD_ERR. If used when rejecting a successful authentication, the
message will be logged in ConfD's audit log (otherwise a generic "rejected
by application callback" message is logged).</p>
<p>Keyword arguments:</p>
<ul>
<li>actx &ndash; the auth context</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.authorization_set_timeout"><code class="name flex">
<span>def <span class="ident">authorization_set_timeout</span></span>(<span>actx, timeout_secs)</span>
</code></dt>
<dd>
<div class="desc"><p>The authorization callbacks are invoked on the daemon control socket, and
as such are expected to complete quickly. However in case they send requests
to a remote server, and such a request needs to be retried, this function
can be used to extend the timeout for the current callback invocation. The
timeout is given in seconds from the point in time when the function is
called.</p>
<p>Keyword arguments:</p>
<ul>
<li>actx &ndash; the authorization context</li>
<li>timeout_secs &ndash; timeout value</li>
</ul></div>
</dd>
<dt id="_confd.dp.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>dx, sock, type, ip, port, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Connects to the ConfD daemon. The socket instance provided via the 'sock'
argument must be kept alive during the lifetime of the daemon context.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>sock &ndash; a Python socket instance</li>
<li>type &ndash; the socket type (CONTROL_SOCKET or WORKER_SOCKET)</li>
<li>ip &ndash; the ip address if socket is AF_INET (optional)</li>
<li>port &ndash; the port if socket is AF_INET (optional)</li>
<li>path &ndash; a filename if socket is AF_UNIX (optional).</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_get_list_filter"><code class="name flex">
<span>def <span class="ident">data_get_list_filter</span></span>(<span>tctx) ‑> <a title="_confd.dp.ListFilter" href="#_confd.dp.ListFilter">ListFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get list filter from transaction context.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_reply_attrs"><code class="name flex">
<span>def <span class="ident">data_reply_attrs</span></span>(<span>tctx, attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the cb_get_attrs() callback to return the
requested attribute values.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>attrs &ndash; a list of _lib.AttrValue instances</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_reply_found"><code class="name flex">
<span>def <span class="ident">data_reply_found</span></span>(<span>tctx)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the cb_exists_optional() callback to indicate to
ConfD that a node does exist.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_reply_next_key"><code class="name flex">
<span>def <span class="ident">data_reply_next_key</span></span>(<span>tctx, keys, next)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the cb_get_next() and cb_find_next() callbacks to
return the next key.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>keys &ndash; a list of keys of _lib.Value for a list item (se below)</li>
<li>next &ndash; int value passed to the next invocation of cb_get_next() callback</li>
</ul>
<p>A list may have mutiple key leafs specified in the data model. This is why
the keys argument must be a list.</p></div>
</dd>
<dt id="_confd.dp.data_reply_next_object_array"><code class="name flex">
<span>def <span class="ident">data_reply_next_object_array</span></span>(<span>tctx, v, next)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the optional cb_get_next_object() and
cb_find_next_object() callbacks to return an entire object including its keys.
It combines the functions of data_reply_next_key() and
data_reply_value_array().</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>v &ndash; a list of _lib.Value instances</li>
<li>next &ndash; int value passed to the next invocation of cb_get_next() callback</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_reply_next_object_arrays"><code class="name flex">
<span>def <span class="ident">data_reply_next_object_arrays</span></span>(<span>tctx, objs, timeout_millisecs)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the optional cb_get_next_object() and
cb_find_next_object() callbacks to return multiple objects including their
keys, in _lib.Value form.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>objs &ndash; a list of tuples or None (see below)</li>
<li>timeout_millisecs &ndash; timeout value for ConfD's caching of returned data</li>
</ul>
<p>The format of argument objs is list(tuple(list(_lib.Value), long)), or
None to indicate end of list. Another way to indicate end of list is to
include None as the first item in the 2-tuple last in the list.</p>
<p>E.g.:</p>
<pre><code>V = _lib.Value
objs = [
         ( [ V(1), V(2) ], next1 ),
         ( [ V(3), V(4) ], next2 ),
         ( None, -1 )
       ]
</code></pre></div>
</dd>
<dt id="_confd.dp.data_reply_next_object_tag_value_array"><code class="name flex">
<span>def <span class="ident">data_reply_next_object_tag_value_array</span></span>(<span>tctx, tvs, next)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the optional cb_get_next_object() and
cb_find_next_object() callbacks to return an entire object including its keys</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>tvs &ndash; a list of _lib.TagValue instances or None</li>
<li>next &ndash; int value passed to the next invocation of cb_get_next_object()
callback</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_reply_next_object_tag_value_arrays"><code class="name flex">
<span>def <span class="ident">data_reply_next_object_tag_value_arrays</span></span>(<span>tctx, objs, timeout_millisecs)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the optional cb_get_next_object() and
cb_find_next_object() callbacks to return multiple objects including their
keys.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>objs &ndash; a list of tuples or None (see below)</li>
<li>timeout_millisecs &ndash; timeout value for ConfD's caching of returned data</li>
</ul>
<p>The format of argument objs is list(tuple(list(_lib.TagValue), long)) or
None to indicate end of list. Another way to indicate end of list is to
include None as the first item in the 2-tuple last in the list.</p>
<p>E.g.:</p>
<pre><code>objs = [
         ( [ tagval1, tagval2 ], next1 ),
         ( [ tagval3, tagval4, tagval5 ], next2 ),
         ( None, -1 )
       ]
</code></pre></div>
</dd>
<dt id="_confd.dp.data_reply_not_found"><code class="name flex">
<span>def <span class="ident">data_reply_not_found</span></span>(<span>tctx)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the cb_get_elem() and cb_exists_optional()
callbacks to indicate to ConfD that a list entry or node does not exist.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_reply_tag_value_array"><code class="name flex">
<span>def <span class="ident">data_reply_tag_value_array</span></span>(<span>tctx, tvs)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to return an array of values, corresponding to a
complete list entry, to ConfD. It can be used by the optional
cb_get_object() callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>tvs &ndash; a list of _lib.TagValue instances or None</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_reply_value"><code class="name flex">
<span>def <span class="ident">data_reply_value</span></span>(<span>tctx, v)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to return a single data item to ConfD.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>v &ndash; a _lib.Value instance</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_reply_value_array"><code class="name flex">
<span>def <span class="ident">data_reply_value_array</span></span>(<span>tctx, vs)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to return an array of values, corresponding to a
complete list entry, to ConfD. It can be used by the optional
cb_get_object() callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>vs &ndash; a list of _lib.Value instances</li>
</ul></div>
</dd>
<dt id="_confd.dp.data_set_timeout"><code class="name flex">
<span>def <span class="ident">data_set_timeout</span></span>(<span>tctx, timeout_secs)</span>
</code></dt>
<dd>
<div class="desc"><p>A data callback should normally complete quickly, since e.g. the
execution of a 'show' command in the CLI may require many data callback
invocations. In some rare cases it may still be necessary for a data
callback to have a longer execution time, and then this function can be
used to extend (or shorten) the timeout for the current callback invocation.
The timeout is given in seconds from the point in time when the function is
called.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>timeout_secs &ndash; timeout value</li>
</ul></div>
</dd>
<dt id="_confd.dp.db_set_timeout"><code class="name flex">
<span>def <span class="ident">db_set_timeout</span></span>(<span>dbx, timeout_secs)</span>
</code></dt>
<dd>
<div class="desc"><p>Some of the DB callbacks registered via register_db_cb(), e.g.
cb_copy_running_to_startup(), may require a longer execution time than
others. This function can be used to extend the timeout for the current
callback invocation. The timeout is given in seconds from the point in
time when the function is called.</p>
<p>Keyword arguments:</p>
<ul>
<li>dbx &ndash; a db context of DbCtxRef</li>
<li>timeout_secs &ndash; timeout value</li>
</ul></div>
</dd>
<dt id="_confd.dp.db_seterr"><code class="name flex">
<span>def <span class="ident">db_seterr</span></span>(<span>dbx, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the application to set an error string.</p>
<p>Keyword arguments:</p>
<ul>
<li>dbx &ndash; a db context</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.db_seterr_extended"><code class="name flex">
<span>def <span class="ident">db_seterr_extended</span></span>(<span>dbx, code, apptag_ns, apptag_tag, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be used to provide more structured error information
from a db callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>dbx &ndash; a db context</li>
<li>code &ndash; an error code</li>
<li>apptag_ns &ndash; namespace - should be set to 0</li>
<li>apptag_tag &ndash; either 0 or the hash value for a data model node</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.db_seterr_extended_info"><code class="name flex">
<span>def <span class="ident">db_seterr_extended_info</span></span>(<span>dbx, code, apptag_ns, apptag_tag, error_info, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be used to provide structured error information in the
same way as db_seterr_extended(), and additionally provide contents for
the NETCONF <error-info> element.</p>
<p>Keyword arguments:</p>
<ul>
<li>dbx &ndash; a db context</li>
<li>code &ndash; an error code</li>
<li>apptag_ns &ndash; namespace - should be set to 0</li>
<li>apptag_tag &ndash; either 0 or the hash value for a data model node</li>
<li>error_info &ndash; a list of _lib.TagValue instances</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.delayed_reply_error"><code class="name flex">
<span>def <span class="ident">delayed_reply_error</span></span>(<span>tctx, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function must be used to return an error when tha actual callback
returned CONFD_DELAYED_RESPONSE.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.delayed_reply_ok"><code class="name flex">
<span>def <span class="ident">delayed_reply_ok</span></span>(<span>tctx)</span>
</code></dt>
<dd>
<div class="desc"><p>This function must be used to return the equivalent of CONFD_OK when the
actual callback returned CONFD_DELAYED_RESPONSE.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
</ul></div>
</dd>
<dt id="_confd.dp.delayed_reply_validation_warn"><code class="name flex">
<span>def <span class="ident">delayed_reply_validation_warn</span></span>(<span>tctx)</span>
</code></dt>
<dd>
<div class="desc"><p>This function must be used to return the equivalent of CONFD_VALIDATION_WARN
when the cb_validate() callback returned CONFD_DELAYED_RESPONSE.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
</ul></div>
</dd>
<dt id="_confd.dp.error_seterr"><code class="name flex">
<span>def <span class="ident">error_seterr</span></span>(<span>uinfo, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function must be called by format_error() (above) to provide a
replacement for the default error message. If format_error() is called
without calling error_seterr() the default message will be used.</p>
<p>Keyword arguments:</p>
<ul>
<li>uinfo &ndash; a user info context</li>
<li>errstr &ndash; an string describing the error</li>
</ul></div>
</dd>
<dt id="_confd.dp.fd_ready"><code class="name flex">
<span>def <span class="ident">fd_ready</span></span>(<span>dx, sock)</span>
</code></dt>
<dd>
<div class="desc"><p>The database application owns all data provider sockets to ConfD and is
responsible for the polling of these sockets. When one of the ConfD
sockets has I/O ready to read, the application must invoke fd_ready() on
the socket.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>sock &ndash; the socket</li>
</ul></div>
</dd>
<dt id="_confd.dp.init_daemon"><code class="name flex">
<span>def <span class="ident">init_daemon</span></span>(<span>name) ‑> <a title="_confd.dp.DaemonCtxRef" href="#_confd.dp.DaemonCtxRef">DaemonCtxRef</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes and returns a new daemon context.</p>
<p>Keyword arguments:</p>
<ul>
<li>name &ndash; a string used to uniquely identify the daemon</li>
</ul></div>
</dd>
<dt id="_confd.dp.install_crypto_keys"><code class="name flex">
<span>def <span class="ident">install_crypto_keys</span></span>(<span>dtx)</span>
</code></dt>
<dd>
<div class="desc"><p>It is possible to define DES3 and AES keys inside confd.conf. These keys
are used by ConfD to encrypt data which is entered into the system which
has either of the two builtin types tailf:des3-cbc-encrypted-string or
tailf:aes-cfb-128-encrypted-string.
This function will copy those keys from ConfD (which reads confd.conf) into
memory in the library.</p>
<p>This function must be called before register_done() is called.</p>
<p>Keyword arguments:</p>
<ul>
<li>dtx &ndash; a daemon context wich is connected through a call to connect()</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_flush"><code class="name flex">
<span>def <span class="ident">notification_flush</span></span>(<span>nctx)</span>
</code></dt>
<dd>
<div class="desc"><p>Notifications are sent asynchronously, i.e. normally without blocking the
caller of the send functions described above. This means that in some cases
ConfD's sending of the notifications on the northbound interfaces may lag
behind the send calls. This function can be used
to make sure that the
notifications have actually been sent out.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_replay_complete"><code class="name flex">
<span>def <span class="ident">notification_replay_complete</span></span>(<span>nctx)</span>
</code></dt>
<dd>
<div class="desc"><p>The application calls this function to notify ConfD that the replay is
complete</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_replay_failed"><code class="name flex">
<span>def <span class="ident">notification_replay_failed</span></span>(<span>nctx)</span>
</code></dt>
<dd>
<div class="desc"><p>In case the application fails to complete the replay as requested (e.g. the
log gets overwritten while the replay is in progress), the application
should call this function instead of notification_replay_complete(). An
error message describing the reason for the failure can be supplied by
first calling notification_seterr() or notification_seterr_extended().</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_reply_log_times"><code class="name flex">
<span>def <span class="ident">notification_reply_log_times</span></span>(<span>nctx, creation, aged)</span>
</code></dt>
<dd>
<div class="desc"><p>Reply function for use in the cb_get_log_times() callback invocation. If no
notifications have been aged out of the log, give None for the aged argument.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
<li>creation &ndash; a _lib.DateTime instance</li>
<li>aged &ndash; a _lib.DateTime instance or None</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_send"><code class="name flex">
<span>def <span class="ident">notification_send</span></span>(<span>nctx, time, values)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is called by the application to send a notification defined
at the top level of a YANG module, whether "live" or replay.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
<li>time &ndash; a _lib.DateTime instance</li>
<li>values &ndash; a list of _lib.TagValue instances or None</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_send_path"><code class="name flex">
<span>def <span class="ident">notification_send_path</span></span>(<span>nctx, time, values, path)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is called by the application to send a notification defined
as a child of a container or list in a YANG 1.1 module, whether "live" or
replay.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
<li>time &ndash; a _lib.DateTime instance</li>
<li>values &ndash; a list of _lib.TagValue instances or None</li>
<li>path &ndash; path to the parent of the notification in the data tree</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_send_snmp"><code class="name flex">
<span>def <span class="ident">notification_send_snmp</span></span>(<span>nctx, notification, varbinds)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends the SNMP notification specified by 'notification', without requesting
inform-request delivery information. This is equivalent to calling
notification_send_snmp_inform() with None as the cb_id argument. I.e. if
the common arguments are the same, the two functions will send the exact
same set of traps and inform-requests.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_snmp_notification()</li>
<li>notification &ndash; the notification string</li>
<li>varbinds &ndash; a list of _lib.SnmpVarbind instances or None</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_send_snmp_inform"><code class="name flex">
<span>def <span class="ident">notification_send_snmp_inform</span></span>(<span>nctx, notification, varbinds, cb_id, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>notification_send_snmp_inform(nctx, notification, varbinds, cb_id, ref) -&gt;None</p>
<p>Sends the SNMP notification specified by notification. If cb_id is not None
the callbacks registered for cb_id will be invoked with the ref argument.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_snmp_notification()</li>
<li>notification &ndash; the notification string</li>
<li>varbinds &ndash; a list of _lib.SnmpVarbind instances or None</li>
<li>cb_id &ndash; callback id</li>
<li>ref &ndash; argument send to callbacks</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_set_fd"><code class="name flex">
<span>def <span class="ident">notification_set_fd</span></span>(<span>nctx, sock)</span>
</code></dt>
<dd>
<div class="desc"><p>This function may optionally be called by the cb_replay() callback to
request that the worker socket given by 'sock' should be used for the
replay. Otherwise the socket specified in register_notification_stream()
will be used.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
<li>sock &ndash; a previously connected worker socket</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_set_snmp_notify_name"><code class="name flex">
<span>def <span class="ident">notification_set_snmp_notify_name</span></span>(<span>nctx, notify_name)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be used to change the snmpNotifyName (notify_name) for
the nctx context.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_snmp_notification()</li>
<li>notify_name &ndash; the snmpNotifyName</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_set_snmp_src_addr"><code class="name flex">
<span>def <span class="ident">notification_set_snmp_src_addr</span></span>(<span>nctx, family, src_addr)</span>
</code></dt>
<dd>
<div class="desc"><p>By default, the source address for the SNMP notifications that are sent by
the above functions is chosen by the IP stack of the OS. This function may
be used to select a specific source address, given by src_addr, for the
SNMP notifications subsequently sent using the nctx context. The default
can be restored by calling the function with family set to AF_UNSPEC.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_snmp_notification()</li>
<li>family &ndash; AF_INET, AF_INET6 or AF_UNSPEC</li>
<li>src_addr &ndash; the source address in string format</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_seterr"><code class="name flex">
<span>def <span class="ident">notification_seterr</span></span>(<span>nctx, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>In some cases the callbacks may be unable to carry out the requested
actions, e.g. the capacity for simultaneous replays might be exceeded, and
they can then return CONFD_ERR. This function allows the callback to
associate an error message with the failure. It can also be used to supply
an error message before calling notification_replay_failed().</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_seterr_extended"><code class="name flex">
<span>def <span class="ident">notification_seterr_extended</span></span>(<span>nctx, code, apptag_ns, apptag_tag, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>notification_seterr_extended(nctx, code, apptag_ns, apptag_tag, errstr) -&gt;None</p>
<p>This function can be used to provide more structured error information
from a notification callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
<li>code &ndash; an error code</li>
<li>apptag_ns &ndash; namespace - should be set to 0</li>
<li>apptag_tag &ndash; either 0 or the hash value for a data model node</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.notification_seterr_extended_info"><code class="name flex">
<span>def <span class="ident">notification_seterr_extended_info</span></span>(<span>nctx, code, apptag_ns, apptag_tag, error_info, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be used to provide structured error information in the
same way as notification_seterr_extended(), and additionally provide
contents for the NETCONF <error-info> element.</p>
<p>Keyword arguments:</p>
<ul>
<li>nctx &ndash; notification context returned from register_notification_stream()</li>
<li>code &ndash; an error code</li>
<li>apptag_ns &ndash; namespace - should be set to 0</li>
<li>apptag_tag &ndash; either 0 or the hash value for a data model node</li>
<li>error_info &ndash; a list of _lib.TagValue instances</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.register_action_cbs"><code class="name flex">
<span>def <span class="ident">register_action_cbs</span></span>(<span>dx, actionpoint, acb)</span>
</code></dt>
<dd>
<div class="desc"><p>This function registers up to five callback functions, two of which will
be called in sequence when an action is invoked.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>actionpoint &ndash; the name of the action point</li>
<li>vcb &ndash; the callback instance (see below)</li>
</ul>
<p>The acb argument should be an instance of a class with callback methods.
E.g.:</p>
<pre><code>class ActionCallbacks(object):
    def cb_init(self, uinfo):
        pass

    def cb_abort(self, uinfo):
        pass

    def cb_action(self, uinfo, name, kp, params):
        pass

    def cb_command(self, uinfo, path, argv):
        pass

    def cb_completion(self, uinfo, cli_style, token, completion_char,
                      kp, cmdpath, cmdparam_id, simpleType, extra):
        pass

acb = ActionCallbacks()
dp.register_action_cbs(dx, 'actionpoint-1', acb)
</code></pre>
<p>Notes about some of the callbacks:</p>
<p>cb_action()
The params argument is a list of _lib.TagValue instances.</p>
<p>cb_command()
The argv argument is a list of strings.</p></div>
</dd>
<dt id="_confd.dp.register_auth_cb"><code class="name flex">
<span>def <span class="ident">register_auth_cb</span></span>(<span>dx, acb)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers the authentication callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>abc &ndash; the callback instance (see below)</li>
</ul>
<p>E.g.:</p>
<pre><code>class AuthCallbacks(object):
    def cb_auth(self, actx):
        pass

acb = AuthCallbacks()
dp.register_auth_cb(dx, acb)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_authorization_cb"><code class="name flex">
<span>def <span class="ident">register_authorization_cb</span></span>(<span>dx, acb, cmd_filter, data_filter)</span>
</code></dt>
<dd>
<div class="desc"><p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>abc &ndash; the callback instance (see below)</li>
<li>cmd_filter &ndash; set to 0 for no filtering</li>
<li>data_filter &ndash; set to 0 for no filtering</li>
</ul>
<p>E.g.:</p>
<pre><code>class AuthorizationCallbacks(object):
    def cb_chk_cmd_access(self, actx, cmdtokens, cmdop):
        pass

    def cb_chk_data_access(self, actx, hashed_ns, hkp, dataop, how):
        pass

acb = AuthCallbacks()
dp.register_authorization_cb(dx, acb)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_data_cb"><code class="name flex">
<span>def <span class="ident">register_data_cb</span></span>(<span>dx, callpoint, data, flags)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers data manipulation callback functions.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>callpoint &ndash; name of a tailf:callpoint in the data model</li>
<li>data &ndash; the callback instance (see below)</li>
<li>flags &ndash; data callbacks flags, dp.DATA_* (optional)</li>
</ul>
<p>The data argument should be an instance of a class with callback methods.
E.g.:</p>
<pre><code>class DataCallbacks(object):
    def cb_exists_optional(self, tctx, kp):
        pass

    def cb_get_elem(self, tctx, kp):
        pass

    def cb_get_next(self, tctx, kp, next):
        pass

    def cb_set_elem(self, tctx, kp, newval):
        pass

    def cb_create(self, tctx, kp):
        pass

    def cb_remove(self, tctx, kp):
        pass

    def cb_find_next(self, tctx, kp, type, keys):
        pass

    def cb_num_instances(self, tctx, kp):
        pass

    def cb_get_object(self, tctx, kp):
        pass

    def cb_get_next_object(self, tctx, kp, next):
        pass

    def cb_find_next_object(self, tctx, kp, type, keys):
        pass

    def cb_get_case(self, tctx, kp, choice):
        pass

    def cb_set_case(self, tctx, kp, choice, caseval):
        pass

    def cb_get_attrs(self, tctx, kp, attrs):
        pass

    def cb_set_attr(self, tctx, kp, attr, v):
        pass

    def cb_move_after(self, tctx, kp, prevkeys):
        pass

    def cb_write_all(self, tctx, kp):
        pass

dcb = DataCallbacks()
dp.register_data_cb(dx, 'example-callpoint-1', dcb)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_db_cb"><code class="name flex">
<span>def <span class="ident">register_db_cb</span></span>(<span>dx, dbcbs)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to set callback functions which span over several
ConfD transactions.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>dbcbs &ndash; the callback instance (see below)</li>
</ul>
<p>The dbcbs argument should be an instance of a class with callback methods.
E.g.:</p>
<pre><code>class DbCallbacks(object):
    def cb_candidate_commit(self, dbx, timeout):
        pass

    def cb_candidate_confirming_commit(self, dbx):
        pass

    def cb_candidate_reset(self, dbx):
        pass

    def cb_candidate_chk_not_modified(self, dbx):
        pass

    def cb_candidate_rollback_running(self, dbx):
        pass

    def cb_candidate_validate(self, dbx):
        pass

    def cb_add_checkpoint_running(self, dbx):
        pass

    def cb_del_checkpoint_running(self, dbx):
        pass

    def cb_activate_checkpoint_running(self, dbx):
        pass

    def cb_copy_running_to_startup(self, dbx):
        pass

    def cb_running_chk_not_modified(self, dbx):
        pass

    def cb_lock(self, dbx, dbname):
        pass

    def cb_unlock(self, dbx, dbname):
        pass

    def cb_lock_partial(self, dbx, dbname, lockid, paths):
        pass

    def cb_ulock_partial(self, dbx, dbname, lockid):
        pass

    def cb_delete_confid(self, dbx, dbname):
        pass

dbcbs = DbCallbacks()
dp.register_db_cb(dx, dbcbs)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_done"><code class="name flex">
<span>def <span class="ident">register_done</span></span>(<span>dx)</span>
</code></dt>
<dd>
<div class="desc"><p>When we have registered all the callbacks for a daemon (including the other
types described below if we have them), we must call this function to
synchronize with ConfD. No callbacks will be invoked until it has been
called, and after the call, no further registrations are allowed.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
</ul></div>
</dd>
<dt id="_confd.dp.register_error_cb"><code class="name flex">
<span>def <span class="ident">register_error_cb</span></span>(<span>dx, errortypes, ecbs)</span>
</code></dt>
<dd>
<div class="desc"><p>This funciton can be used to register error callbacks that are
invoked for internally generated errors.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>errortypes &ndash; logical OR of the error types that the ecbs should handle</li>
<li>ecbs &ndash; the callback instance (see below)</li>
</ul>
<p>E.g.:</p>
<pre><code>class ErrorCallbacks(object):
    def cb_format_error(self, uinfo, errinfo_dict, default_msg):
        dp.error_seterr(uinfo, default_msg)
ecbs = ErrorCallbacks()
dp.register_error_cb(ctx,
                     dp.ERRTYPE_BAD_VALUE |
                     dp.ERRTYPE_MISC, ecbs)
dp.register_done(ctx)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_notification_snmp_inform_cb"><code class="name flex">
<span>def <span class="ident">register_notification_snmp_inform_cb</span></span>(<span>dx, cb_id, cbs)</span>
</code></dt>
<dd>
<div class="desc"><p>If we want to receive information about the delivery of SNMP
inform-requests, we must register two callbacks for this.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>cb_id &ndash; the callback identifier</li>
<li>cbs &ndash; the callback instance (see below)</li>
</ul>
<p>E.g.:</p>
<pre><code>class NotifySnmpCallbacks(object):
    def cb_targets(self, nctx, ref, targets):
        pass

    def cb_result(self, nctx, ref, target, got_response):
        pass

cbs = NotifySnmpCallbacks()
dp.register_notification_snmp_inform_cb(dx, 'callback-id-1', cbs)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_notification_stream"><code class="name flex">
<span>def <span class="ident">register_notification_stream</span></span>(<span>dx, ncbs, sock, streamname) ‑> <a title="_confd.dp.NotificationCtxRef" href="#_confd.dp.NotificationCtxRef">NotificationCtxRef</a></span>
</code></dt>
<dd>
<div class="desc"><p>This function registers the notification stream and optionally two callback
functions used for the replay functionality.</p>
<p>The returned notification context must be used by the application for the
sending of live notifications via notification_send() or
notification_send_path().</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>ncbs &ndash; the callback instance (see below)</li>
<li>sock &ndash; a previously connected worker socket</li>
<li>streamname &ndash; the name of the notification stream</li>
</ul>
<p>E.g.:</p>
<pre><code>class NotificationCallbacks(object):
    def cb_get_log_times(self, nctx):
        pass

    def cb_replay(self, nctx, start, stop):
        pass

ncbs = NotificationCallbacks()
livectx = dp.register_notification_stream(dx, ncbs, workersock,
'streamname')
</code></pre></div>
</dd>
<dt id="_confd.dp.register_notification_sub_snmp_cb"><code class="name flex">
<span>def <span class="ident">register_notification_sub_snmp_cb</span></span>(<span>dx, sub_id, cbs)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a callback function to be called when an SNMP notification is
received by the SNMP gateway.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>sub_id &ndash; the subscription id for the notifications</li>
<li>cbs &ndash; the callback instance (see below)</li>
</ul>
<p>E.g.:</p>
<pre><code>class NotifySubSnmpCallbacks(object):
    def cb_recv(self, nctx, notification, varbinds, src_addr, port):
        pass

cbs = NotifySubSnmpCallbacks()
dp.register_notification_sub_snmp_cb(dx, 'sub-id-1', cbs)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_range_action_cbs"><code class="name flex">
<span>def <span class="ident">register_range_action_cbs</span></span>(<span>dx, actionpoint, acb, lower, upper, path)</span>
</code></dt>
<dd>
<div class="desc"><p>A variant of register_action_cbs() which registers action callbacks for a
range of key values. The lower, upper, and path arguments are the same as
for register_range_data_cb().</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>actionpoint &ndash; the name of the action point</li>
<li>data &ndash; the callback instance (see register_action_cbs())</li>
<li>lower &ndash; a list of Value's or None</li>
<li>upper &ndash; a list of Value's or None</li>
<li>path &ndash; path for the list (string)</li>
</ul></div>
</dd>
<dt id="_confd.dp.register_range_data_cb"><code class="name flex">
<span>def <span class="ident">register_range_data_cb</span></span>(<span>dx, callpoint, data, lower, upper, path, flags)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a variant of register_data_cb() which registers a set of callbacks
for a range of list entries.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>callpoint &ndash; name of a tailf:callpoint in the data model</li>
<li>data &ndash; the callback instance (see register_data_cb())</li>
<li>lower &ndash; a list of Value's or None</li>
<li>upper &ndash; a list of Value's or None</li>
<li>path &ndash; path for the list (string)</li>
<li>flags &ndash; data callbacks flags, dp.DATA_* (optional)</li>
</ul></div>
</dd>
<dt id="_confd.dp.register_range_valpoint_cb"><code class="name flex">
<span>def <span class="ident">register_range_valpoint_cb</span></span>(<span>dx, valpoint, vcb, lower, upper, path)</span>
</code></dt>
<dd>
<div class="desc"><p>A variant of register_valpoint_cb() which registers a validation function
for a range of key values. The lower, upper and path arguments are the same
as for register_range_data_cb().</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>valpoint &ndash; name of a validation point</li>
<li>data &ndash; the callback instance (see register_valpoint_cb())</li>
<li>lower &ndash; a list of Value's or None</li>
<li>upper &ndash; a list of Value's or None</li>
<li>path &ndash; path for the list (string)</li>
</ul></div>
</dd>
<dt id="_confd.dp.register_snmp_notification"><code class="name flex">
<span>def <span class="ident">register_snmp_notification</span></span>(<span>dx, sock, notify_name, ctx_name) ‑> <a title="_confd.dp.NotificationCtxRef" href="#_confd.dp.NotificationCtxRef">NotificationCtxRef</a></span>
</code></dt>
<dd>
<div class="desc"><p>SNMP notifications can also be sent via the notification framework, however
most aspects of the stream concept do not apply for SNMP. This function is
used to register a worker socket, the snmpNotifyName (notify_name), and
SNMP context (ctx_name) to be used for the notifications.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>sock &ndash; a previously connected worker socket</li>
<li>notify_name &ndash; the snmpNotifyName</li>
<li>ctx_name &ndash; the SNMP context</li>
</ul></div>
</dd>
<dt id="_confd.dp.register_trans_cb"><code class="name flex">
<span>def <span class="ident">register_trans_cb</span></span>(<span>dx, trans)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers transaction callback functions.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>trans &ndash; the callback instance (see below)</li>
</ul>
<p>The trans argument should be an instance of a class with callback methods.
E.g.:</p>
<pre><code>class TransCallbacks(object):
    def cb_init(self, tctx):
        pass

    def cb_trans_lock(self, tctx):
        pass

    def cb_trans_unlock(self, tctx):
        pass

    def cb_write_start(self, tctx):
        pass

    def cb_prepare(self, tctx):
        pass

    def cb_abort(self, tctx):
        pass

    def cb_commit(self, tctx):
        pass

    def cb_finish(self, tctx):
        pass

    def cb_interrupt(self, tctx):
        pass

tcb = TransCallbacks()
dp.register_trans_cb(dx, tcb)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_trans_validate_cb"><code class="name flex">
<span>def <span class="ident">register_trans_validate_cb</span></span>(<span>dx, vcbs)</span>
</code></dt>
<dd>
<div class="desc"><p>This function installs two callback functions for the daemon context. One
function that gets called when the validation phase starts in a transaction
and one when the validation phase stops in a transaction.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>vcbs &ndash; the callback instance (see below)</li>
</ul>
<p>The vcbs argument should be an instance of a class with callback methods.
E.g.:</p>
<pre><code>class TransValidateCallbacks(object):
    def cb_init(self, tctx):
        pass

    def cb_stop(self, tctx):
        pass

vcbs = TransValidateCallbacks()
dp.register_trans_validate_cb(dx, vcbs)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_usess_cb"><code class="name flex">
<span>def <span class="ident">register_usess_cb</span></span>(<span>dx, ucb)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be used to register information callbacks that are
invoked for user session start and stop.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>ucb &ndash; the callback instance (see below)</li>
</ul>
<p>E.g.:</p>
<pre><code>class UserSessionCallbacks(object):
    def cb_start(self, dx, uinfo):
        pass

    def cb_stop(self, dx, uinfo):
        pass

ucb = UserSessionCallbacks()
dp.register_usess_cb(dx, acb)
</code></pre></div>
</dd>
<dt id="_confd.dp.register_valpoint_cb"><code class="name flex">
<span>def <span class="ident">register_valpoint_cb</span></span>(<span>dx, valpoint, vcb)</span>
</code></dt>
<dd>
<div class="desc"><p>We must also install an actual validation function for each validation
point, i.e. for each tailf:validate statement in the YANG data model.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>valpoint &ndash; the name of the validation point</li>
<li>vcb &ndash; the callback instance (see below)</li>
</ul>
<p>The vcb argument should be an instance of a class with a callback method.
E.g.:</p>
<pre><code>class ValpointCallback(object):
    def cb_validate(self, tctx, kp, newval):
        pass

vcb = ValpointCallback()
dp.register_valpoint_cb(dx, 'valpoint-1', vcb)
</code></pre></div>
</dd>
<dt id="_confd.dp.release_daemon"><code class="name flex">
<span>def <span class="ident">release_daemon</span></span>(<span>dx)</span>
</code></dt>
<dd>
<div class="desc"><p>Releases all memory that has been allocated by init_daemon() and other
functions for the daemon context. The control socket as well as all the
worker sockets must be closed by the application (before or after
release_daemon() has been called).</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
</ul></div>
</dd>
<dt id="_confd.dp.set_daemon_flags"><code class="name flex">
<span>def <span class="ident">set_daemon_flags</span></span>(<span>dx, flags)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies the API behaviour according to the flags ORed into the flags
argument.</p>
<p>Keyword arguments:</p>
<ul>
<li>dx &ndash; a daemon context acquired through a call to init_daemon()</li>
<li>flags &ndash; the flags to set</li>
</ul></div>
</dd>
<dt id="_confd.dp.trans_set_fd"><code class="name flex">
<span>def <span class="ident">trans_set_fd</span></span>(<span>tctx, sock)</span>
</code></dt>
<dd>
<div class="desc"><p>Associate a worker socket with the transaction, or validation phase. This
function must be called in the transaction and validation cb_init()
callbacks.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>sock &ndash; a previously connected worker socket</li>
</ul>
<p>A minimal implementation of a transaction cb_init() callback looks like:</p>
<pre><code>class TransCb(object):
    def __init__(self, workersock):
        self.workersock = workersock

    def cb_init(self, tctx):
        dp.trans_set_fd(tctx, self.workersock)
</code></pre></div>
</dd>
<dt id="_confd.dp.trans_seterr"><code class="name flex">
<span>def <span class="ident">trans_seterr</span></span>(<span>tctx, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used by the application to set an error string.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.trans_seterr_extended"><code class="name flex">
<span>def <span class="ident">trans_seterr_extended</span></span>(<span>tctx, code, apptag_ns, apptag_tag, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be used to provide more structured error information
from a transaction or data callback.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>code &ndash; an error code</li>
<li>apptag_ns &ndash; namespace - should be set to 0</li>
<li>apptag_tag &ndash; either 0 or the hash value for a data model node</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
<dt id="_confd.dp.trans_seterr_extended_info"><code class="name flex">
<span>def <span class="ident">trans_seterr_extended_info</span></span>(<span>tctx, code, apptag_ns, apptag_tag, error_info, errstr)</span>
</code></dt>
<dd>
<div class="desc"><p>This function can be used to provide structured error information in the
same way as trans_seterr_extended(), and additionally provide contents for
the NETCONF <error-info> element.</p>
<p>Keyword arguments:</p>
<ul>
<li>tctx &ndash; a transaction context</li>
<li>code &ndash; an error code</li>
<li>apptag_ns &ndash; namespace - should be set to 0</li>
<li>apptag_tag &ndash; either 0 or the hash value for a data model node</li>
<li>error_info &ndash; a list of _lib.TagValue instances</li>
<li>errstr &ndash; an error message string</li>
</ul></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="_confd.dp.AuthCtxRef"><code class="flex name class">
<span>class <span class="ident">AuthCtxRef</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>This type represents the c-type struct confd_auth_ctx.</p>
<p>Available attributes:</p>
<ul>
<li>uinfo &ndash; the user info (UserInfo)</li>
<li>method &ndash; the method (string)</li>
<li>success &ndash; success or failure (bool)</li>
<li>groups &ndash; authorization groups if success is True (list of strings)</li>
<li>logno &ndash; log number if success is False (int)</li>
<li>reason &ndash; error reason if success is False (string)</li>
</ul>
<p>AuthCtxRef cannot be directly instantiated from Python.</p></div>
</dd>
<dt id="_confd.dp.AuthorizationCtxRef"><code class="flex name class">
<span>class <span class="ident">AuthorizationCtxRef</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>This type represents the c-type struct confd_authorization_ctx.</p>
<p>Available attributes:</p>
<ul>
<li>uinfo &ndash; the user info (UserInfo) or None</li>
<li>groups &ndash; authorization groups (list of strings) or None</li>
</ul>
<p>AuthorizationCtxRef cannot be directly instantiated from Python.</p></div>
</dd>
<dt id="_confd.dp.DaemonCtxRef"><code class="flex name class">
<span>class <span class="ident">DaemonCtxRef</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>struct confd_daemon_ctx references object</p></div>
</dd>
<dt id="_confd.dp.DbCtxRef"><code class="flex name class">
<span>class <span class="ident">DbCtxRef</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>This type represents the c-type struct confd_db_ctx.</p>
<p>DbCtxRef cannot be directly instantiated from Python.</p></div>
<h3>Methods</h3>
<dl>
<dt id="_confd.dp.DbCtxRef.did"><code class="name flex">
<span>def <span class="ident">did</span></span>(<span>) ‑> <a title="int" href="https://docs.python.org/3/library/functions.html#int">int</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="_confd.dp.DbCtxRef.dx"><code class="name flex">
<span>def <span class="ident">dx</span></span>(<span>) ‑> <a title="_confd.dp.DaemonCtxRef" href="#_confd.dp.DaemonCtxRef">DaemonCtxRef</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="_confd.dp.DbCtxRef.lastop"><code class="name flex">
<span>def <span class="ident">lastop</span></span>(<span>) ‑> <a title="int" href="https://docs.python.org/3/library/functions.html#int">int</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="_confd.dp.DbCtxRef.qref"><code class="name flex">
<span>def <span class="ident">qref</span></span>(<span>) ‑> <a title="int" href="https://docs.python.org/3/library/functions.html#int">int</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="_confd.dp.DbCtxRef.uinfo"><code class="name flex">
<span>def <span class="ident">uinfo</span></span>(<span>) ‑> <a title="_confd.UserInfo" href="index.html#_confd.UserInfo">UserInfo</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="_confd.dp.ListFilter"><code class="flex name class">
<span>class <span class="ident">ListFilter</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>This type represents the c-type struct confd_list_filter.</p>
<p>Available attributes:</p>
<ul>
<li>type &ndash; filter type, LF_*</li>
<li>expr1 &ndash; OR, AND, NOT expression</li>
<li>expr2 &ndash; OR, AND expression</li>
<li>op &ndash; operation, CMP_<em> and EXEC_</em></li>
<li>node &ndash; filter tagpath</li>
<li>val &ndash; filter value</li>
</ul>
<p>ListFilter cannot be directly instantiated from Python.</p></div>
</dd>
<dt id="_confd.dp.NotificationCtxRef"><code class="flex name class">
<span>class <span class="ident">NotificationCtxRef</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>This type represents the c-type struct confd_notification_ctx.</p>
<p>Available attributes:</p>
<ul>
<li>name &ndash; stream name or snmp notify name (string or None)</li>
<li>ctx_name &ndash; for snmp only (string or None)</li>
<li>fd &ndash; worker socket (int)</li>
<li>dx &ndash; the daemon context (DaemonCtxRef)</li>
</ul>
<p>NotificationCtxRef cannot be directly instantiated from Python.</p></div>
</dd>
<dt id="_confd.dp.TrItemRef"><code class="flex name class">
<span>class <span class="ident">TrItemRef</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>This type represents the c-type confd_tr_item.</p>
<p>Available attributes:</p>
<ul>
<li>callpoint &ndash; the callpoint (string)</li>
<li>op &ndash; operation, one of C_SET_ELEM, C_CREATE, C_REMOVE, C_SET_CASE,
C_SET_ATTR or C_MOVE_AFTER (int)</li>
<li>hkp &ndash; the keypath (HKeypathRef)</li>
<li>val &ndash; the value (Value or None)</li>
<li>choice &ndash; the choice, only for C_SET_CASE (Value or None)</li>
<li>attr &ndash; attribute, only for C_SET_ATTR (int or None)</li>
<li>next &ndash; the next TrItemRef object in the linked list or None if no more
items are found</li>
</ul>
<p>TrItemRef cannot be directly instantiated from Python.</p></div>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="_confd" href="index.html">_confd</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="_confd.dp.aaa_reload" href="#_confd.dp.aaa_reload">aaa_reload</a></code></li>
<li><code><a title="_confd.dp.access_reply_result" href="#_confd.dp.access_reply_result">access_reply_result</a></code></li>
<li><code><a title="_confd.dp.action_delayed_reply_error" href="#_confd.dp.action_delayed_reply_error">action_delayed_reply_error</a></code></li>
<li><code><a title="_confd.dp.action_delayed_reply_ok" href="#_confd.dp.action_delayed_reply_ok">action_delayed_reply_ok</a></code></li>
<li><code><a title="_confd.dp.action_reply_command" href="#_confd.dp.action_reply_command">action_reply_command</a></code></li>
<li><code><a title="_confd.dp.action_reply_completion" href="#_confd.dp.action_reply_completion">action_reply_completion</a></code></li>
<li><code><a title="_confd.dp.action_reply_range_enum" href="#_confd.dp.action_reply_range_enum">action_reply_range_enum</a></code></li>
<li><code><a title="_confd.dp.action_reply_rewrite" href="#_confd.dp.action_reply_rewrite">action_reply_rewrite</a></code></li>
<li><code><a title="_confd.dp.action_reply_rewrite2" href="#_confd.dp.action_reply_rewrite2">action_reply_rewrite2</a></code></li>
<li><code><a title="_confd.dp.action_reply_values" href="#_confd.dp.action_reply_values">action_reply_values</a></code></li>
<li><code><a title="_confd.dp.action_set_fd" href="#_confd.dp.action_set_fd">action_set_fd</a></code></li>
<li><code><a title="_confd.dp.action_set_timeout" href="#_confd.dp.action_set_timeout">action_set_timeout</a></code></li>
<li><code><a title="_confd.dp.action_seterr" href="#_confd.dp.action_seterr">action_seterr</a></code></li>
<li><code><a title="_confd.dp.action_seterr_extended" href="#_confd.dp.action_seterr_extended">action_seterr_extended</a></code></li>
<li><code><a title="_confd.dp.action_seterr_extended_info" href="#_confd.dp.action_seterr_extended_info">action_seterr_extended_info</a></code></li>
<li><code><a title="_confd.dp.auth_seterr" href="#_confd.dp.auth_seterr">auth_seterr</a></code></li>
<li><code><a title="_confd.dp.authorization_set_timeout" href="#_confd.dp.authorization_set_timeout">authorization_set_timeout</a></code></li>
<li><code><a title="_confd.dp.connect" href="#_confd.dp.connect">connect</a></code></li>
<li><code><a title="_confd.dp.data_get_list_filter" href="#_confd.dp.data_get_list_filter">data_get_list_filter</a></code></li>
<li><code><a title="_confd.dp.data_reply_attrs" href="#_confd.dp.data_reply_attrs">data_reply_attrs</a></code></li>
<li><code><a title="_confd.dp.data_reply_found" href="#_confd.dp.data_reply_found">data_reply_found</a></code></li>
<li><code><a title="_confd.dp.data_reply_next_key" href="#_confd.dp.data_reply_next_key">data_reply_next_key</a></code></li>
<li><code><a title="_confd.dp.data_reply_next_object_array" href="#_confd.dp.data_reply_next_object_array">data_reply_next_object_array</a></code></li>
<li><code><a title="_confd.dp.data_reply_next_object_arrays" href="#_confd.dp.data_reply_next_object_arrays">data_reply_next_object_arrays</a></code></li>
<li><code><a title="_confd.dp.data_reply_next_object_tag_value_array" href="#_confd.dp.data_reply_next_object_tag_value_array">data_reply_next_object_tag_value_array</a></code></li>
<li><code><a title="_confd.dp.data_reply_next_object_tag_value_arrays" href="#_confd.dp.data_reply_next_object_tag_value_arrays">data_reply_next_object_tag_value_arrays</a></code></li>
<li><code><a title="_confd.dp.data_reply_not_found" href="#_confd.dp.data_reply_not_found">data_reply_not_found</a></code></li>
<li><code><a title="_confd.dp.data_reply_tag_value_array" href="#_confd.dp.data_reply_tag_value_array">data_reply_tag_value_array</a></code></li>
<li><code><a title="_confd.dp.data_reply_value" href="#_confd.dp.data_reply_value">data_reply_value</a></code></li>
<li><code><a title="_confd.dp.data_reply_value_array" href="#_confd.dp.data_reply_value_array">data_reply_value_array</a></code></li>
<li><code><a title="_confd.dp.data_set_timeout" href="#_confd.dp.data_set_timeout">data_set_timeout</a></code></li>
<li><code><a title="_confd.dp.db_set_timeout" href="#_confd.dp.db_set_timeout">db_set_timeout</a></code></li>
<li><code><a title="_confd.dp.db_seterr" href="#_confd.dp.db_seterr">db_seterr</a></code></li>
<li><code><a title="_confd.dp.db_seterr_extended" href="#_confd.dp.db_seterr_extended">db_seterr_extended</a></code></li>
<li><code><a title="_confd.dp.db_seterr_extended_info" href="#_confd.dp.db_seterr_extended_info">db_seterr_extended_info</a></code></li>
<li><code><a title="_confd.dp.delayed_reply_error" href="#_confd.dp.delayed_reply_error">delayed_reply_error</a></code></li>
<li><code><a title="_confd.dp.delayed_reply_ok" href="#_confd.dp.delayed_reply_ok">delayed_reply_ok</a></code></li>
<li><code><a title="_confd.dp.delayed_reply_validation_warn" href="#_confd.dp.delayed_reply_validation_warn">delayed_reply_validation_warn</a></code></li>
<li><code><a title="_confd.dp.error_seterr" href="#_confd.dp.error_seterr">error_seterr</a></code></li>
<li><code><a title="_confd.dp.fd_ready" href="#_confd.dp.fd_ready">fd_ready</a></code></li>
<li><code><a title="_confd.dp.init_daemon" href="#_confd.dp.init_daemon">init_daemon</a></code></li>
<li><code><a title="_confd.dp.install_crypto_keys" href="#_confd.dp.install_crypto_keys">install_crypto_keys</a></code></li>
<li><code><a title="_confd.dp.notification_flush" href="#_confd.dp.notification_flush">notification_flush</a></code></li>
<li><code><a title="_confd.dp.notification_replay_complete" href="#_confd.dp.notification_replay_complete">notification_replay_complete</a></code></li>
<li><code><a title="_confd.dp.notification_replay_failed" href="#_confd.dp.notification_replay_failed">notification_replay_failed</a></code></li>
<li><code><a title="_confd.dp.notification_reply_log_times" href="#_confd.dp.notification_reply_log_times">notification_reply_log_times</a></code></li>
<li><code><a title="_confd.dp.notification_send" href="#_confd.dp.notification_send">notification_send</a></code></li>
<li><code><a title="_confd.dp.notification_send_path" href="#_confd.dp.notification_send_path">notification_send_path</a></code></li>
<li><code><a title="_confd.dp.notification_send_snmp" href="#_confd.dp.notification_send_snmp">notification_send_snmp</a></code></li>
<li><code><a title="_confd.dp.notification_send_snmp_inform" href="#_confd.dp.notification_send_snmp_inform">notification_send_snmp_inform</a></code></li>
<li><code><a title="_confd.dp.notification_set_fd" href="#_confd.dp.notification_set_fd">notification_set_fd</a></code></li>
<li><code><a title="_confd.dp.notification_set_snmp_notify_name" href="#_confd.dp.notification_set_snmp_notify_name">notification_set_snmp_notify_name</a></code></li>
<li><code><a title="_confd.dp.notification_set_snmp_src_addr" href="#_confd.dp.notification_set_snmp_src_addr">notification_set_snmp_src_addr</a></code></li>
<li><code><a title="_confd.dp.notification_seterr" href="#_confd.dp.notification_seterr">notification_seterr</a></code></li>
<li><code><a title="_confd.dp.notification_seterr_extended" href="#_confd.dp.notification_seterr_extended">notification_seterr_extended</a></code></li>
<li><code><a title="_confd.dp.notification_seterr_extended_info" href="#_confd.dp.notification_seterr_extended_info">notification_seterr_extended_info</a></code></li>
<li><code><a title="_confd.dp.register_action_cbs" href="#_confd.dp.register_action_cbs">register_action_cbs</a></code></li>
<li><code><a title="_confd.dp.register_auth_cb" href="#_confd.dp.register_auth_cb">register_auth_cb</a></code></li>
<li><code><a title="_confd.dp.register_authorization_cb" href="#_confd.dp.register_authorization_cb">register_authorization_cb</a></code></li>
<li><code><a title="_confd.dp.register_data_cb" href="#_confd.dp.register_data_cb">register_data_cb</a></code></li>
<li><code><a title="_confd.dp.register_db_cb" href="#_confd.dp.register_db_cb">register_db_cb</a></code></li>
<li><code><a title="_confd.dp.register_done" href="#_confd.dp.register_done">register_done</a></code></li>
<li><code><a title="_confd.dp.register_error_cb" href="#_confd.dp.register_error_cb">register_error_cb</a></code></li>
<li><code><a title="_confd.dp.register_notification_snmp_inform_cb" href="#_confd.dp.register_notification_snmp_inform_cb">register_notification_snmp_inform_cb</a></code></li>
<li><code><a title="_confd.dp.register_notification_stream" href="#_confd.dp.register_notification_stream">register_notification_stream</a></code></li>
<li><code><a title="_confd.dp.register_notification_sub_snmp_cb" href="#_confd.dp.register_notification_sub_snmp_cb">register_notification_sub_snmp_cb</a></code></li>
<li><code><a title="_confd.dp.register_range_action_cbs" href="#_confd.dp.register_range_action_cbs">register_range_action_cbs</a></code></li>
<li><code><a title="_confd.dp.register_range_data_cb" href="#_confd.dp.register_range_data_cb">register_range_data_cb</a></code></li>
<li><code><a title="_confd.dp.register_range_valpoint_cb" href="#_confd.dp.register_range_valpoint_cb">register_range_valpoint_cb</a></code></li>
<li><code><a title="_confd.dp.register_snmp_notification" href="#_confd.dp.register_snmp_notification">register_snmp_notification</a></code></li>
<li><code><a title="_confd.dp.register_trans_cb" href="#_confd.dp.register_trans_cb">register_trans_cb</a></code></li>
<li><code><a title="_confd.dp.register_trans_validate_cb" href="#_confd.dp.register_trans_validate_cb">register_trans_validate_cb</a></code></li>
<li><code><a title="_confd.dp.register_usess_cb" href="#_confd.dp.register_usess_cb">register_usess_cb</a></code></li>
<li><code><a title="_confd.dp.register_valpoint_cb" href="#_confd.dp.register_valpoint_cb">register_valpoint_cb</a></code></li>
<li><code><a title="_confd.dp.release_daemon" href="#_confd.dp.release_daemon">release_daemon</a></code></li>
<li><code><a title="_confd.dp.set_daemon_flags" href="#_confd.dp.set_daemon_flags">set_daemon_flags</a></code></li>
<li><code><a title="_confd.dp.trans_set_fd" href="#_confd.dp.trans_set_fd">trans_set_fd</a></code></li>
<li><code><a title="_confd.dp.trans_seterr" href="#_confd.dp.trans_seterr">trans_seterr</a></code></li>
<li><code><a title="_confd.dp.trans_seterr_extended" href="#_confd.dp.trans_seterr_extended">trans_seterr_extended</a></code></li>
<li><code><a title="_confd.dp.trans_seterr_extended_info" href="#_confd.dp.trans_seterr_extended_info">trans_seterr_extended_info</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="_confd.dp.AuthCtxRef" href="#_confd.dp.AuthCtxRef">AuthCtxRef</a></code></h4>
</li>
<li>
<h4><code><a title="_confd.dp.AuthorizationCtxRef" href="#_confd.dp.AuthorizationCtxRef">AuthorizationCtxRef</a></code></h4>
</li>
<li>
<h4><code><a title="_confd.dp.DaemonCtxRef" href="#_confd.dp.DaemonCtxRef">DaemonCtxRef</a></code></h4>
</li>
<li>
<h4><code><a title="_confd.dp.DbCtxRef" href="#_confd.dp.DbCtxRef">DbCtxRef</a></code></h4>
<ul class="">
<li><code><a title="_confd.dp.DbCtxRef.did" href="#_confd.dp.DbCtxRef.did">did</a></code></li>
<li><code><a title="_confd.dp.DbCtxRef.dx" href="#_confd.dp.DbCtxRef.dx">dx</a></code></li>
<li><code><a title="_confd.dp.DbCtxRef.lastop" href="#_confd.dp.DbCtxRef.lastop">lastop</a></code></li>
<li><code><a title="_confd.dp.DbCtxRef.qref" href="#_confd.dp.DbCtxRef.qref">qref</a></code></li>
<li><code><a title="_confd.dp.DbCtxRef.uinfo" href="#_confd.dp.DbCtxRef.uinfo">uinfo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="_confd.dp.ListFilter" href="#_confd.dp.ListFilter">ListFilter</a></code></h4>
</li>
<li>
<h4><code><a title="_confd.dp.NotificationCtxRef" href="#_confd.dp.NotificationCtxRef">NotificationCtxRef</a></code></h4>
</li>
<li>
<h4><code><a title="_confd.dp.TrItemRef" href="#_confd.dp.TrItemRef">TrItemRef</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>